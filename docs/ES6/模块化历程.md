# 前端模块化历程

## 前言

在李录的《文明、现代化、价值投资与中国》里，他把人类的文明史分为三大跃升阶段：即 1.0 狩猎采集文明、2.0 农业文明和 3.0 科技文明。针对 JavaScript 的模块化，笔者认为模块化历程也可类比为这样的历程。在前端页面不复杂的情况下，我们只需引入需要的库、js 文件或模块，这就像“狩猎采集文明”时，饿了去打猎、摘果子一样，及时反馈，速度 NO1；后来NodeJS 兴起，让前端有了操作文件的能力，这时候就进入了农业文明时代，这里有两个标准最为突出，一是 NodeJS 社区推崇的 CommonJS，一个是浏览器推崇的 AMD，两个之所以有所不同，是因为两者所处的位置不同；之后发展演变，ECMAScript 提出了统一标准 ESM 标准，这也是前端模块化的终点，也就是“3.0 科技文明”时代

我会在每个阶段中讲解这些每个时代代表性的解决方案和库，让你清晰地了解前端模块化的发展历程

狩猎采集阶段——IIFE 统治前端工程化

- 文件、注释划分方式
- 函数方式
- 命名空间方式
- IIFE（立即执行函数）

农业文明阶段——CommonJS 与 AMD

- CommonJS 
- AMD

科技文明阶段——ESM 延续至今

- ESM 
- 前端打包库的兴起







## 狩猎采集阶段——IIFE 统治前端工程化

最开始的模块

#### 从设计模块说起

```javascript
function foo() {}

function bar() {}
```

全局被污染，很容易命名冲突

#### 简单封装：命名空间模式

```javascript
var MYAPP = {
  foo: function () {},
  bar: function () {},
};

MYAPP.foo();
```

减少全局上的变量数

本质是对象，一点都不安全

#### 匿名闭包：IIFE 模块

```javascript
var Module = (function () {
  var _private = 'safe now';
  var foo = function () {
    console.log(_private);
  };
  return {
    foo: foo,
  };
})();

Module.foo(); // 私有变量
Module._private; // undefined
```

函数是 JavaScript 唯一的 Local Scope（作用域）

#### 再增强一点：引入依赖

```javascript
var Module = (function ($) {
  var _$body = $('body'); // we can use jQuery now!
  var foo = function () {
    console.log(_$body); // 特权方法
  };
  return {
    foo: foo,
  };
})(jQuery);

Module.foo();
```

这就是模块模式，也是现代模块实现的基石





### IIFE

```html
<script>
  var module1 = (function () {
    var x = 1;
    return { a: x };
  })();
</script>
<script>
  var module2 = (function () {
    var a = module1.a;
    return { b: a };
  })();
</script>
```

在 ES6 的模块化还没出来之前，一些库或者模块是通过 IIFE（立即执行函数）来实现的。关于 IIFE，我们之前在 JavaScript 篇的 [立即执行函数（IIFE）](../JavaScript/立即执行函数（IIFE）.md) 中提到过





## 农业文明阶段——CommonJS 与 AMD







但用这种方式的缺点：扩展的模块无法共享原有模块的内部属性，还有模块本身常常依赖其他模块，模块模式无法实现这些依赖关系

缺点：

- 随着项目扩展，html 文件中会包含大量的 script 标签
- script 的依赖关系难以用 script 标签的先后顺序组织

为了解决这个问题，出现了两个互相竞争的标准，即 Asynchronous Module Definition（AMD）和 CommonJS

AMD 和 CommonJS 是两个相互竞争的标准，均可以定义 JavaScript 模块。除了语法和原理的区别之外，主要的区别是 AMD 的设计理念是明确基于浏览器，而 CommonJS 的设计是面向通用 JavaScript 环境（如 Node.js 服务端），而不局限于浏览器。

AMD 异步

CommonJS 同步

### AMD

AMD 可以很容易指定模块及依赖关系。同时，它支持浏览器。目前，AMD 最流行的实现是 RequireJS（http://requirejs.org/）。

#### 使用姿势

```javascript
define(['jquery', 'common', 'errorMsg'], function($, common, errorMsg) {
    var Home = function() {
        ...
    };
    return Home;
})
```

RequireJS 声明一个模块是，必须指定所有的依赖项，这些依赖项会被当做形参传到 factory 中，对于依赖的模块会提前执行（在 RequireJS 2.0 也可以选择延迟执行），这被称为：依赖前置

但是这会带来说明问题呢？

加大了开发过程中的难度，无论是阅读之前的代码还是编写新的内容，会出现这样的情况：引入的另一个模块中的内容是条件性执行的

### CMD（Common Module Definition） & SeaJS

CMD 是除 AMD 以外的另外一种模块组织规范。CMD 即 Common Module Definition，意为“通用模块定义”。

针对 AMD 规范中可以优化的部分，[CMD 规范](https://github.com/cmdjs/specification/blob/master/draft/module.md) 出现了，而 [SeaJS](https://github.com/seajs/seajs) 则作为它的具体实现之一，与 AMD 十分相似：

```javascript
// AMD 的一个例子，当然这是一种极端的情况
define(['header', 'main', 'footer'], function (header, main, footer) {
  if (xxx) {
    header.setHeader('new-title');
  }
  if (xxx) {
    main.setMain('new-content');
  }
  if (xxx) {
    footer.setFooter('new-footer');
  }
});

// 与之对应的 CMD 的写法
define(function (require, exports, module) {
  if (xxx) {
    var header = require('./header');
    header.setHeader('new-title');
  }
  if (xxx) {
    var main = require('./main');
    main.setMain('new-content');
  }
  if (xxx) {
    var footer = require('./footer');
    footer.setFooter('new-footer');
  }
});
```

AMD 与 CMD 最大的区别：

一方面，在依赖的处理上

- AMD 推崇依赖前置，即通过依赖数组的方式提前声明当前模块的依赖
- CMD 推崇依赖就近，在编译需要用到的时候通过调用 require 方法动态引入

另一方面，在本模块的对外输出上

- AMD 推崇通过返回值的方式对外输出
- CMD 推崇通过给 module.exports 赋值的方式对外输出

### AMD && CMD 背后的实现原理

一种解决方 案是采用 UMD（Universal Module Definition, https://github.com/umdjs/umd），这种模式的语法有点复杂，它同时支持 AMD 和 CommonJS。





## 科技文明阶段——ESM 延续至今

### ES6 Module

ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：`export`和`import`。

### 

### 前端打包库的兴起

Webpack-集大成者

几乎对任何资源或资产进行转换，捆绑或打包

Rollup

ES6 模块







## 总结

我想说的就是模块化的发展啊

介绍模块化发展历程

IIFE(声明即执行的函数表达式)，特点：**在一个单独的函数作用于中执行代码，避免变量冲突**

```javascript
(function () {
  return {
    data: [],
  };
})();
```

**AMD:** 使用 requireJS 来编写模块化，特点：**依赖必须提前声明好**

```javascript
define('./index.js', function (code) {
  // code 就是index.Js 返回的内容
});
```

**CMD:** 使用 seaJS 来编写模块化，特点： **支持动态引入依赖**

```javascript
define(function (require, exports, moduke) {
  var indexCode = require('./index.js');
});
```

**CommonJS:** nodejs 中自带的模块化

```javascript
var fs = require('fs');
```

exports 指向 module.exports，即 exports = model.exports

**UMD:** 是 AMD 和 CommonJS 的糅合，跨平台的解决方案

**ES Modules：** ES6 引入的模块化，支持 import 来引入另一个 js

ES6 模块与 CommonJS 模块的差异

CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用

CommonJS 模块是运行时加载，ES6 模块是编译时输出接口

AMD 和 CMD 最大的区别是对依赖模块的执行时机处理不同

AMD：依赖前置，提前执行

CMD：依赖就近，延迟执行

ESM（ES6 module）

export 只支持对象形式导出，不支持值的导出，export default 命令用于指定模块的默认输出，只支持值导出，但是只能指定一个，本质上它就是输出一个叫做 default 的变量或方法

CommonJs 因为是同步执行，所以如果在浏览器上使用 CommonJS，会引起浏览器的假死（卡住）

AMD 规范是异步加载模块，允许指定回调函数，代表函数库：`require.js`

`require.js` 主要解决两个问题：

- 异步加载模块
- 模块之间依赖模糊

CMD 是阿里的玉伯提出的，js 的函数为 `sea.js` 。它与 `require.js` 最主要的区别是实现了按需加载，推崇依赖就近原则，模块延迟执行

UMD 是 AMD 和 CommonJS 的综合产物

ifelse 的写法

ES6 的模块化，可以使用 `import` 关键字引入模块， 通过`export` 关键字导出模块

与 CommonJS 的差异

- CommonJS 模块输出的是一个值的拷贝， ES6 模块输出的是值的引用
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口





## 参考资料

- [JavaScript 模块化七日谈](https://huangxuan.me/js-module-7day/#/)

- [前端模块化的十年征程](https://zhuanlan.zhihu.com/p/265632724)

- [从 CommonJS 到 Sea.js](https://github.com/seajs/seajs/issues/269)

- [前端模块化开发那点历史](https://github.com/seajs/seajs/issues/588)
- [JS 模块化规范总结(面试必备良药)](https://mp.weixin.qq.com/s?__biz=MzA4ODUzNTE2Nw==&mid=2451046624&idx=1&sn=5e148a4785b54730e3673ba709882a24&chksm=87c419f0b0b390e61fc91695c663e27ed130c28e30307d4576c43023b4bf6964ef2f56645d61&mpshare=1&scene=1&srcid=&sharer_sharetime=1576713268652&sharer_shareid=778ad5bf3b27e0078eb105d7277263f6#rd)
- [[前端漫谈\_5] 从 IIFE 聊到 Babel 带你深入了解前端模块化发展体系](https://juejin.cn/post/6844903829448687624)
- [ES6 系列之模块加载方案](https://github.com/mqyqingfeng/Blog/issues/108)
- [【THE LAST TIME】深入浅出 JavaScript 模块化](https://mp.weixin.qq.com/s/y4A6Wc00fmdWRWmuj0ae5g)
- [ESModule 系列 ㈠ ：演进](https://mp.weixin.qq.com/s/XmwfKLQrRlZ4z0niz5mLJg)
- [浏览器中的 ESM](https://mp.weixin.qq.com/s/JZW6S6LLIOGrBGfbD173rQ)
