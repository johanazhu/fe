# let 和 const

https://www.cnblogs.com/zhuzhenwei918/p/6131345.html



我用了两个月的时间才理解 let

https://zhuanlan.zhihu.com/p/28140450



块级作用域和暂时性死区。

之前的var变量，会有变量提升的概念。即你在任何处用var定义变量，一开始js引擎会将其变量置位顶部（以 `undefined` 的形式，再执行到赋值时，再赋值）

但是用let、const 声明的变量，则不会有变量提升的概念，在定义let之前，不能调用let声明的变量，不然会报错，在块级作用域的开始到let声明的前一行，这块区域被称为`暂时性死区`





变量提升和暂时性死区

var会变量提升

function会函数提升

函数提升的优先级大于变量提升



let、const会引起暂时性死区

为什么？

因为

变量提升和暂时性死区算feature(特性)还是bug



ES6规定，let/const 命令会使区块形成封闭的作用域。如在声明之前使用变量，就会报错。

总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。

这在语法上，称为“**暂时性死区**”（temporal dead zone，简称TDZ）



也就是说由let、const声明的变量，在使用之前，这些变量都是不可用的

var 声明的会在预编译阶段进行变量提升，并且赋值undefined

非表达式的函数也会进行函数声明，它的优先级大于var





阮一峰：

> ES6 规定暂时性死区和`let`、`const`语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。

















作用域

​	

代码提升是在预编译阶段进行，而代码执行阶段



预编译阶段会做三件事

​	变量声明

​	变量声明并进行提升，但是值为 undefined

​	所有非表达式的函数声明进行提升（函数声明）



![image-20210604173150466](https://i.loli.net/2021/06/04/9uaTpg7C3l8XxNb.png)

1. 当脚本开始运行，词法环境预先填充了所有的变量
   - 最初，它们处于“未初始化（Uninitiallized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 `let` 声明前，不能引用它。几乎就像变量不存在一样。
2. 然后 `let phrase` 定义出现了。它尚未被赋值，因此它的值为 `undefined` 。从这一刻起，我们就可以使用变量了。



第一个阶段，就是暂时性死区



### 参考资料

[闭包](https://zh.javascript.info/closure)





