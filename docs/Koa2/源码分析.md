# 从浅入深了解Koa2源码



再前文我们介绍过什么是 koa2

简单回顾下，

什么是koa2

1. NodeJS的web开发框架
2. 异步解决方案



特点

中间件机制

​	洋葱模型

​	compose 





## 源码结构

Koa2 的源码地址：https://github.com/koajs/koa

其中 lib 为其源码

![koa2源码](https://i.loli.net/2021/08/26/toxOpd5H6XEwaQj.png)

可以看出，只有四个文件：`application.js`、`context.js`、`request.js`、`response.js`

## application

为入口文件，它继承了 Emitter 模块，Emitter 模块是 NodeJS 原生的模块，我们在[这篇文章](../Node/Emitter.md)中曾经介绍过它，简单来说，Emitter 模块能实现事件监听和事件触发能力

![application1](https://i.loli.net/2021/08/26/JqloRhD7zLaCSdm.png)

使用 class 来写类可以看看这篇：[class](../ES6/class.md)，这里默认你已经会 class 了

删掉注释，从整理看  `Application`  构造函数

![Application构造函数](https://i.loli.net/2021/08/26/swAqmIGTVCuZ2M6.png)

Application 在其原型上提供了 listen、toJSON、inspect、use、callback、handleRequest、createContext、onerror 等八个方法，其中

- listen：提供 HTTP 服务
- use：中间件挂载
- callback：获取 http server 所需要的 callback 函数
- createContext：构造 ctx，合并 node 的req、res，构造 Koa 的 参数——ctx
- onerror：错误处理

其他的先不要在意，我们再来看看 构造器  `constructor` 

![Application的构造器](https://i.loli.net/2021/08/26/Emlw8daN3ZTuDvJ.png)

晕，这都啥和啥，我们启动一个最简单的服务，看看实例

```javascript
const Koa = require('Koa')

const app = new Koa()

app.use((ctx) => {
  ctx.body = 'hello world'
})

app.listen(3000, () => {
  console.log('3000请求成功')
})

console.dir(app)
```

![实例](https://i.loli.net/2021/08/26/kda3JfI9AoCPpVt.png)

能看出来，我们的实例和构造器一一对应，



打断点看原型

![image-20210826160023261](https://i.loli.net/2021/08/26/WJzLP3FAKqTwy96.png)







### 先看 listen

```javascript
...
  listen(...args) {
    const server = http.createServer(this.callback())
    return server.listen(...args)
  }
...
```

可以看出 listen 就是用 http 模块封装了一个 http 服务，重点是传入的 `this.callback()`。好，我们现在就去看 callback 

### callback

```javascript
  callback() {
    const fn = compose(this.middleware)
    const handleRequest = (req, res) => {
      const ctx = this.createContext(req, res)
      return this.handleRequest(ctx, fn)
    }
    return handleRequest
  }
```

它包含了中间件的合并，上下文的处理，以及 res 的特殊处理

#### 中间件的合并

使用了 `koa-compose` 来合并中间件，这也是洋葱模型的关键，koa-compose 的源码地址：https://github.com/koajs/compose。这代码已经三年没动了，绝对的稳

```javascript
function compose (middleware) {
  return function (context, next) {
    let index = -1
    return dispatch(0)
    function dispatch (i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}
```

一晃眼是看不明白的，我们需要先明白 middleware 是什么，即中间件数组，那它是怎么来的呢，构造器中有 this.middleware，谁使用到了—— use 方法

我们先跳出去先看 use 方法

### use

```javascript
use(fn) {
    this.middleware.push(fn)
    return this
}
```

除去异常处理，关键在这两步，`this.middleware` 是一个数组，第一步往 `this.middleware` 中 push 中间件；第二步返回 this 让其可以链式调用，当初本人被面试如何做 promise 的链式调用，懵逼脸，没想到在这里看到了

回过头来看 koa-compose 源码，

设想一下这种场景

```javascript
...
app.use(async (ctx, next) => {
    console.log(1);
    await next();
    console.log(6);
});
app.use(async (ctx, next) => {
    console.log(2);
    await next();
    console.log(5);
});

app.use(async (ctx, next) => {
    console.log(3);
    ctx.body = "hello world";
    console.log(4);
});
...
```

我们知道 它的运行是 123456

它的 this.middleware 的构成是

```javascript
this.middleware = [
    async (ctx, next) => {
        console.log(1);
        await next();
        console.log(6);
    },
    async (ctx, next) => {
        console.log(2);
        await next();
        console.log(5);
    },
    async (ctx, next) => {
        console.log(3);
        ctx.body = "hello world";
        console.log(4);
    }
]
```

不要感到奇怪，函数也是对象之一，是对象就可以传值

 `const fn = compose(this.middleware)`

我们将其 JavaScript 化，其他不用改，只需要把最后一个函数改成

```javascript
async (ctx, next) => {
    console.log(3);
    -ctx.body = "hello world";
    +console.log('hello world');
    console.log(4);
}
```



![测试compose](https://i.loli.net/2021/08/26/bSfzDjPWnVx6JCU.png)

![测试compose2](https://i.loli.net/2021/08/26/rSN5GpudU2KimLW.png)

### 逐行解析 koa-compose

这一段很重要，面试的时候常考，让你手写一个 compose ，淦它

```javascript
//1. async (ctx, next) => { console.log(1); await next(); console.log(6); } 中间件
//2. const fn = compose(this.middleware) 合并中间件
//3. fn() 执行中间件

function compose (middleware) {
  return function (context, next) {
    let index = -1
    return dispatch(0)
    function dispatch (i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}
```

执行 `const fn = compose(this.middleware)`，即如下代码

```javascript
const fn = function (context, next) {
    let index = -1
    return dispatch(0)
    function dispatch (i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}
```

执行 `fn()`，即如下代码：

```javascript
const fn = function (context, next) {
    let index = -1
    return dispatch(0)
    function dispatch (i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'))
      index = i	// index = 0
      let fn = middleware[i] // fn 为第一个中间件
      if (i === middleware.length) fn = next // 跳过
      if (!fn) return Promise.resolve() // 跳过
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))
          // 返回一个 Promise 实例，执行 递归执行 dispatch(1)
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}
```

也就是第一个中间件，要先等第二个中间件执行完才返回，第二个要等第三个执行完才返回，直到中间件执行执行完毕

关于 Promise 的知识我们可以去看看[这篇文章](../ES6/Promise.md)，这里要说的是

Promise.resolve就是个~~渣女~~ Promise 实例

