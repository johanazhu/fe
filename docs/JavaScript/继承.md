# 继承



JavaScript 的主流继承方式，选择了隐式原型继承，它提供了几个内置的 constructor 函数，如 Object，Array，Boolean，String，Number 等

当我们使用对象字面量创建一个新对象时，它有两层隐式行为。

（1）隐式的通过 new Object() 去创建对象

（2）隐式的进行原型继承

可以说，JS 原型之所以难以理解，主要原因是设计上的问题，而非技术难度。

如果将 constructor 函数的 prototype 改名为 properties 。问题可能少很多。或者进一步简写成 props，理解上将更加简单。不就是 new Constructor 时，自带了它的 Constructor.props 对象嘛



https://github.com/mqyqingfeng/Blog/issues/16





不对

因此，他就把new命令引入了Javascript，用来从原型对象生成一个实例对象。但是，Javascript没有"类"，怎么来表示原型对象呢？

原型对象本身是一个函数，

实例 = new 原型对象

原型对象是实例的妈妈



Brendan Eich 决定为构造函数设置一个 prototype 属性

这个属性包含一个对象（以下简称“prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那么不需要共享的属性和方法，就放在构造函数里面



由于所有的实例对象共享同一个prototype 对象，那么从外界看起来，prototype 对象就好像是实例对象的原型，而实例对象则好像“继承”了prototype 对象一样





所谓"构造函数"，其实就是一个普通函数，但是内部使用了[`this`变量](http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html)。对构造函数使用`new`运算符，就能生成实例，并且`this`变量会绑定在实例对象上。



每个构造函数都有 prototype 属性，是不是说每个函数都有 prototype 属性

这意味着，我们可以把那些不变的属性和方法，直接定义在 `prototyoe` 对象上































问：两个构造函数之间如何继承？

或者问：ConstructorB 如何继承 ConstructorA？



JS 里的继承，是对象跟对象之间的继承。constructor 的主要用途是初始化对象的属性。

因此，两个Constructor 之间的继承，需要分开两个步骤。

第一步：编写constructor，将两个 constructor 通过 call/apply 的方法，合并它们的属性初始化。按照超类优先的顺序进行

第二步：取出超类和之类的原型对象，通过 Object.create/Object.setPrototypeOf 显式原型继承的方式，设置子类的原型为超类原型。



#### class的方式继承：

```javascript
class Student {
    constructor(name) {
        this.name = name
    }
    sayName() {
        console.log(this.name)
    }
}
class PrimaryStudent extends Student {
	constructor(name, grade) {
        super(name)
        this.grade = grade;
    }
    sayGrade() {
        console.log(this.grade)
    }
}

```





#### prototype 的方式继承：

```javascript
function Student(name) {
    this.name = name;
}
Student.prototype.sayName = function() {
    console.log(this.name)
}

function PrimaryStudent(name, grade) {
    Student.call(this, name)
    this.grade = grade;
}
PrimaryStudent.prototype = Object.create(Student.prototype);
PrimaryStudent.prototype.constructor = PrimaryStudent;
PrimaryStudent.prototype.sayGrade = function() {
    console.log(this.grade);
}
```
