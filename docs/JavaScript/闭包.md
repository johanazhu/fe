# 闭包



### 为什么要有闭包？

我们去了解一个概念时，如果先问一句，为什么会有它（这个概念），往往很多东西就能不攻自破

为什么会有闭包，它产生的原因是什么，解决了什么？

我们不妨试想一下以下场景。你实现一个 web 应用，写了很多页面，同样引入了一些库和框架，自己又写了很多工具函数，当他们在一个（全局）作用域下，就会引发变量冲突问题（虽然我们强调命名规范问题，但实际开发总会遇到命名相同等问题）

假设你定义了一个变量a，一个函数b，直接写在全局环境下，这个模块实现了功能A。

现在我们的程序需要开发功能B，你也想用变量a，函数b标识符来表示，那就尴尬了，因为已经在功能A上使用过，不能再使用，而如果不用变量a和函数b标识符来表示语义化上又不洽淡。

你也许想到了c、d两个名字，但是当你调试时，发现原来这两个标识符也已经被其他的工具函数使用过。

命名冲突的原因是因为 **同作用域下已存在相同的变量名**，要解决以上问题，就要从作用域上下手

即——**一个模块应该有自己的作用域，来保证模块的正常运行**

全局作用域肯定不行，我们只用函数作用域可以实现这一功能。SO 我们要讲的闭包本质上就是一个函数作用域

它的作用是对**模块中变量的保护**。即在函数作用域中写好所有流程后，讲这个要使用的变量return语句暴露到外界

```javascript
function foo() {
    var a = '我是 foo 的私有变量，只能在 foo 中使用';
    function b() {
        console.log('我是 foo 中的私有函数，只能在 foo 中使用')
    }
    function closuresab() { // 将 foo 中的私有变量打包到 closuresab 中
        b();
     	console.log(a)   
    }
    return closuresab
}
var bar = foo()
bar() 
// 我是 foo 中的私有函数，只能在 foo 中使用
// 我是 foo 的私有变量，只能在 foo 中使用
```

这让我们在全局中调用bar()，来得到函数内的变量

这就是闭包的作用。**闭包其实只是一个绑定了执行环境的函数**

#### 我的理解

因为作用域是词法作用域，函数内定义的变量函数外不能使用。如果我想调用函数内的变量呢？怎么破？返回调用变量的函数，这样即使这个调用完这个父层函数，子函数也能以闭包的形式继续存留下来。作用域就释放不了，这就是闭包的原因

```javascript
function foo(){
    var a = 2; // 私有变量，属于 foo
    return function() { // 返回一个匿名函数，匿名函数中调用a
        a++
        console.log(a)
    }
}
var bar = foo() // 将 foo 函数赋值给 bar
bar() // 3
bar() // 4
```

如上所示，我明明在函数外面，但是我还是调用了函数里面的变量。我们再来个例子一下

```javascript
function foo(){
    return function(name) { // 返回一个回调函数
        console.log(name)
    }
}
var bar = foo() // 将 foo 函数赋值给 bar
bar('elaine') // elaine
```

是不是很熟悉，回调函数竟然是闭包

Jquery 中有大量的回调函数例子：

```javascript
function setupBot(name, selector) {
    $(selector).click(function() {
        console.log('调用', name)
    })
}
setupBot('closure Bot 1', '#bot1')
setupBot('closure Bot 2', '#bot2')
```

我们可以得出这样的结论：只要使用了**回调函数**，实际上就是在使用闭包！



闭包的原理也相对简单，本质是函数作用域的作用，其概念是：利用函数作用域保护自由变量，并且返回了对被保护变量的引用，这种行为就是闭包。

闭包无处不在，比如我们熟悉的回调函数，只要使用了就自然有闭包。







深入javascript——作用域和闭包

https://segmentfault.com/a/1190000000618597







#### 闭包

什么是：即重用一个变量，又保护变量不被篡改的一个机制

为什么会有它

​	全局变量： 优：可重用

​						缺：造成全局污染，易被篡改

​	局部变量： 优：仅函数内可使用，不会污染全局，也不会被篡改

​						缺：不可重用

何时：只要希望重用一个变量，又保护变量不被污染

闭包的题目很多
hook也是用了闭包的机制
要多写一些案例

react hooks 中有闭包陷阱

被压着释放不了



说说我对JavaScript 闭包的理解

https://juejin.im/post/5a65cfa4f265da3e377c2491



重温基础：闭包

https://mp.weixin.qq.com/s?__biz=MzIyMDc3NTEyNA==&mid=2247484083&idx=1&sn=67c1763e172a8192ce2a4d1f0f025e51&chksm=97c79508a0b01c1e738d976ef06f8a55d207765cbe22f8646092caa5d42c291f1ab941ea76e8&mpshare=1&scene=1&srcid=&sharer_sharetime=1568854610501&sharer_shareid=778ad5bf3b27e0078eb105d7277263f6#rd



一文读懂 javascript 中的闭包

https://mp.weixin.qq.com/s?__biz=MzU3MzcxMzg2Mw==&mid=2247483924&idx=1&sn=fa69401f5b562dd81dcf1c4162852908&chksm=fd3c3ebcca4bb7aafca6548e862af76c49daf5282b7c5b9d2b4c46400782a78fe8bcf49a377a&token=1491323947&lang=zh_CN&scene=21#wechat_redirect





闭包是如何工作的？

执行上下文，词法环境





闭包的应用场景：（1）函数作为返回值；（2）函数作为参数传递



闭包就是 执行上下文没有销毁（原因：作用域链），占内存，作用：函数外操作函数内的变量



闭包的意义：

既能使用局部变量，又不污染全局



阮一峰对闭包的理解

https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html



设计闭包（Closure）的初衷是为了解决什么问题？

闭包是函数式编程及其核心思想“Lambda 计算法”（Lambda Calculus）的必备基础设定



闭包：函数外部可以控制函数内部的变量



```javascript
function foo() {
    var x = 10;
    function bar() {
        console.log(x)
    }
    return bar
}
var x = 20;
foo()()
```

产生闭包的原因，作用域

因为javascript是词法作用域，在哪里定义作用域就作用于哪里，bar在foo的作用域中，当调用foo()，返回的是函数 bar，再调用foo()()，即bar()，打印x，因为bar在作用域foo中，所以当x自由变量在bar函数中找不到变量时，迎着作用域链往上走，就到了foo，找到变量x= 10，那就能打印出 x = 10

如果我们将foo函数中的`var x = 10;`删掉，

```javascript
function foo() {
    function bar() {
        console.log(x)
    }
    return bar
}
var x = 20;
foo()()
```

你觉得会打印什么？

x = 20

为什么？

迎着作用域往上找，找不到才会报错，但是全局作用域中有x，就打印出x

另外，我这里有一个疑问，使用`foo()()`，debugger时没有看到闭包，但是先给foo() 赋值，再调用它会看到闭包







在编程语言中，闭包表示一种函数
闭包其实是一个绑定了执行环境的函数



闭包，作用域的引用导致的结果



闭包能做什么？

https://juejin.im/post/6844903769646317576#heading-10





闭包与普通函数的区别是，它携带了执行的环境

重学前端



闭包

https://zh.javascript.info/closure



### 闭包的延伸

#### 柯里化函数



#### 函数式编程



#### redux-thunk的源码





http://www.alloyteam.com/2019/07/closure/



闭包最简单的例子

```javascript
function counterCreator() {
    let index = 1;
    return function() {
        return index++
    }
}
const counterA = counterCreator()
counterA() // 1
counterA() // 2
// 闭包，index 一直存在内存中，没有被(垃圾)回收
```

说说闭包：

https://github.com/LuckyWinty/fe-weekly-questions/issues/71


https://zh.javascript.info/closure

当代码要访问一个变量时——首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。

无论函数在何处调用，可用的变量总是包括“定义该函数时的可用变量”



闭包是为了达到某种目的而实现的技术，其原理是利用javascript的作用域。javascript的作用域是词法作用域，与在哪里定义有关（与在哪里调用无关）。所以你在一个函数中定义变量，再返回带有此变量的函数，暴露出去是，变量不会随着调用完毕而被垃圾回收回收，这就是闭包











如果要理解闭包。需要提前了解几个知识点。因为闭包不是一个单一的概念，它是由作用域、作用域链、执行上下文、调用栈、内存管理等多重知识相结合的概念

之前我们讲过作用域。简单来说，作用域分三种，一是全局作用域，二是函数作用域。三是块级作用域。函数内部能调用函数外部的变量。函数定义时，即产生了作用域链

块级作用域和暂时性死区。

之前的var变量，会有变量提升的概念。即你在任何处用var定义变量，一开始会js引擎会将其变量置位顶部（以 `undefined` 的形式，再执行到赋值时，再赋值）

但是用let、const 声明的变量，则不会有变量提升的概念，在定义let之前，不能调用let声明的变量，不然会报错，在块级作用域的开始到let声明的前一行，这块区域被称为`暂时性死区`





 比如我们可以利用闭包实现“模块化” 





闭包其实只是一个绑定了执行环境的函数

闭包与普通函数的区别是，它鞋带了执行环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境



实际上JavaScript中跟闭包对应的概念就是“函数”



《黑客与画家》

闭包（lexical closure） 一个函数，通过它可以引用由包含这个函数的代码所定义的变量。



神三元

闭包产生的本质就是，当前环境中存在指向父级作用域的引用

```javascript
function f1() {
    var a = 2;
    function f2() {
        console.log(a); //2
    }
    return f2
}
var x = f1();
x();
```

f1() 函数赋值给x，即 x = f2函数（f1函数执行返回f2）。再次执行x()就是执行f2函数。而f2处于 f1的函数内，因为JavaScript作用域的特性——词法作用域，所以f2的作用域链为f2—f1—window。那么查找f2中的a时，先在f2中查看，找不到再向上一层查找，即f1，找到自由变量a后，打印a，完毕





闭包是为了达到某种目的而实现的技术，其原理是利用了js的作用域，js 的作用域是词法作用域，与在哪里定义有关（与被谁调用无关）。所以你在一个函数中定义变量，再返回带有此变量的函数，供人调用时，变量不会随着调用完毕而被垃圾回收收回，这就是闭包







MDN对闭包的定义为：

> 闭包时指哪些能够访问自由变量的函数

那么什么时自由变量呢？

> 自由变量时指在函数中使用的，但既不是函数参数也不是函数局部变量的变量

由此，我们可以看出闭包共又两部分组成：

> 闭包 = 函数 + 函数能够访问的自由变量



从实践角度：以下函数才算是闭包：

1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
2. 在代码中引用了自由变量



看到 `function` 应该想到什么，创建新函数 



用途：即重用一个变量，又保护变量不被污染的一种编程方法

为什么会有闭包：

全局变量和局部变量都有不可兼得的优缺点：

全局变量：优点：可重用；缺点：易被污染

局部变量：优点：不被污染，缺点：不可重用







压住了没有释放



执行外层函数，外层函数压入执行栈中，调用它时返回一个函数，这个函数被调用着，所以能保持状态（没有释放）

前提：内层函数调用外层函数中的变量。因为使用着外层函数中的变量，所以无法释放

为什么无法释放？执行上下文栈在调用着

闭包住的函数，调用，闭包函数内部的变量变化，调用完后，退出执行上下文栈，此时，内部的变量已经变化了

这也是闭包的特性：改变函数内部的变量







就像 你不知道的 JavaScript 中讲的：

> 闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意 识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿 来识别、拥抱和影响闭包的思维环境。





最简单的闭包例子

```javascript
function foo() {
    var a = 2;
    
    function bar() {
        console.log(a);
    }
    
    return bar;
}

var baz = foo();

baz(); // 2 —— 这就是闭包

```



垃圾回收器会释放不在使用的内存空间，

闭包会阻止这件事发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用



这个函数在定义时的词法作用域意外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域



无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包



本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使 用了回调函数，实际上就是在使用闭包