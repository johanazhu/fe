# 闭包



### 前言：

网络中有各种各样说闭包的文章，有些浅尝辄止，有些CV党，又有些只讲一部分。对我而言，要想了解闭包，需要掌握的知识点有 `词法环境(或者是ES中的变量对象)` 、`执行上下文与执行栈` 、 `(词法)作用域` 、 `作用域链` 等等。

好在我们在之前的已经梳理了这几块的内容：[词法作用域](./作用域.md)、[词法环境](./词法环境.md)、[执行上下文](./执行上下文与调用栈.md) 。接下来让我们揭开闭包的面纱，从外到内认清克利奥帕特拉七世（闭包）



### 一句话解释：

闭包就是一个绑定了执行环境的函数，它利用了词法作用域的特性，在函数嵌套时，内层函数引用外层函数作用域下的变量，并且内层函数在全局环境下可访问，就形成了闭包



### 为什么要有闭包？

在讲闭包之前，我们不妨问自己一下，为什么会有它（这个概念），它解决了什么问题？

试想一下以下场景。你实现一个 web 应用，写了很多页面，同样引入了一些库和框架，自己又写了很多工具函数，当他们在一个（全局）作用域下，就会引发变量冲突问题（虽然我们强调命名规范问题，但实际开发总会遇到命名相同等问题）

假设你定义了一个变量a，一个函数b，直接写在全局环境下，这个模块实现了功能A。现在我们的程序需要开发功能B，你也想用变量a，函数b标识符来表示，那就尴尬了，因为已经在功能A上使用过，不能再使用，而如果不用变量a和函数b标识符来表示语义化上又不洽淡。

你也许想到了c、d两个名字，但是当你调试时，发现原来这两个标识符也已经被其他的工具函数使用过。

命名冲突的原因是因为 **同作用域下已存在相同的变量名**，要解决以上问题，就要从作用域上下手，

即——**一个模块应该有自己的作用域，来保证模块的正常运行**

全局作用域肯定不行，我们只用函数作用域可以实现这一功能。所以**闭包其实是利用了函数作用域实现的一种变量保护机制**

它的作用是**对模块中变量的保护**。即在函数作用域中写好代码后，将要使用的变量 return 语句暴露到外界

```javascript
function outer() {
    var a = '私有变量，只能在 outer 中使用';
    function inner() {
        console.log('我是 outer 中的私有函数，只能在 outer 中使用')
    }
    function closureOuter() {
        inner()
        console.log(a)
    }
    return closureOuter
}

var bar = outer()
bar()
// 我是 outer 中的私有函数，只能在 outer 中使用
// 私有变量，只能在 outer 中使用
```

我们以这个 demo 为例，来说一说整个过程。因为词法作用域，外层函数不能访问内层函数的变量。所以函数 `outer` 外不能使用 `outer` 内的变量 `a` 和函数 `inner`。但是如果我们调用函数 `outer` 时赋值给 `bar` ，返回的是函数 `outer` 内的函数 `closureOuter` ，此时的 `bar` 指向函数  `closureOuter` ，函数 `closureOuter` 因为词法环境的原因，能访问变量 `a` 和函数 `inner` 。当调用 `bar` 时，执行函数 `clousureOuter` ，执行 `inner` 和打印变量 `a` 

我们也可以这样理解，`outer` 就是一个模块，它暴露 `closureOuter`  给外界，外界调用 `outer` 模块，能使用 `outer` 的变量，但是不能对内部的变量做修改（保护变量）

回到开头所说，为什么要有闭包，因为只有使用闭包才能实现对变量的保护，**闭包其实是一个绑定了执行环境（执行上下文）的函数**



### 各路大神对闭包的定义：

winter：

> 闭包其实只是一个绑定了执行环境的函数
>
> 闭包与普通函数的区别是，它携带了执行环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境
>
> 实际上 JavaScript 中跟闭包对应的概念就是“函数”

候策

> 函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可访问，就形成了闭包。

黑客与画家

> 闭包（lexical closure） 一个函数，通过它可以引用由包含这个函数的代码所定义的变量

神三元

> 闭包产生的本质就是，当前环境中存在指向父级作用域的引用

MDN对闭包的定义为：

> 闭包时指哪些能够访问自由变量的函数

那什么是自由变量呢？

> 自由变量是指在函数中使用的，但既不是函数参数也不是函数局部变量的变量

由此，我们可以看出闭包共又两部分组成

> 闭包 = 函数 + 函数能够访问的自由变量

 《你不知道的 JavaScript》 

> 闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。

李兵《浏览器工作原理与实践》

> 在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。



### 闭包形成的原理

闭包的本质是利用函数作用域保护自由变量，并且返回了对被保护变量的引用，这种行为就是闭包

我们先快速复习一下这三个知识点：[词法作用域](./作用域.md)、[词法环境](./词法环境.md)、[执行上下文](./执行上下文与调用栈.md) 。

词法作用域：词法作用域就是定义在词法阶段的作用域

词法环境：在代码编译阶段记录变量声明、函数声明、函数声明形参的合集？

执行上下文：调用函数时所带的所有信息

```javascript
function foo() {
    var a = 1;
    function bar() {
        console.log(a++)
    }
    bar()
}
foo()
```



```javascript
function foo() {
    var a = 1;
    return function bar() {
        console.log(a++)
    }
}
var baz = foo()
baz()
```



代码执行时，会将代码压入执行上下文栈中，等执行完再从上下文栈中弹出，函数和全局变量才能压入执行上下文栈，在压入函数时，会执行上下文中存储变量，等执行完后，弹出函数，释放变量；闭包是虽然你释放了外层的函数，但是你内层的函数被引用（一般赋值为一个变量），所以外层函数中的变量没有被释放，一直存在内存中，这就是闭包的原理





### 函数声明

一个函数其实也是一个值，就像变量一样

**不同之处在于函数声明的初始化会被立即完成**



正常来说，这种行为仅适用于函数声明，而不适用于我们将函数分配给变量的函数表达式，例如 `let say = function(name)...`。





### 内部和外部的词法环境

在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数（相当于压入执行上下文栈中）



**当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。**





### 闭包的用途及应用场景

用途：即重用一个变量，又保护变量不被污染的一种编程方法

闭包的应用场景：（1）函数作为返回值；（2）函数作为参数传递

注意到没有，无论是函数作为返回值，还是函数作为参数传递，本质都是函数在预编译时生成作用域，而只要这个函数使用了函数外的变量，调用完外层函数后，没有弹出执行上下文栈





就像上文中介绍，闭包是为了解决私有变量

在 ES6 的 class 没有之前，JavaScript只能借助闭包，在函数中赋值变量，并返回带有变量的函数，举个例子：

```javascript
function counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}
var c1 = counter();
c1.inc() // 1
c1.inc() // 2
c1.inc() // 3

var c2 = counter(10);
c1.inc() // 11
c1.inc() // 12
c1.inc() // 13
```

在返回的对象中，实现了一个闭包，该闭包携带了局部变量`x` ，并且外部代码根本无法范文到变量`x` 。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏。



#### 私有实例变量

```javascript
function Car(manufacturer, model, year, color) {
    return {
        toString() {
            return `${manufacturer} ${model} (${year}, ${color})`
        }
    }
}
const car = new Car('Aston Martin','V8 Vantage', '2021', 'red')
console.log(car.toString())
```



#### 函数式编程

```javascript
function curry(fn) {
    const args = []
    return function inner(arg) {
        if (args.length === fn.length) return fn(...args)
        args.push(arg)
        return inner
    }
}

function add(a, b) {
    return a + b
}

const curriedAdd = curry(add)
console.log(curriedAdd(2)(3)()) // 5
```

设计闭包（Closure）的初衷是为了解决什么问题？

闭包是函数式编程及其核心思想“Lambda 计算法”（Lambda Calculus）的必备基础设定

闭包能做什么？

https://juejin.im/post/6844903769646317576#heading-10



#### 面向事件编程

```javascript
const $ = document.querySelector.bind(document);
const BACKGROUND_COLOR = 'rgba(200, 200, 242, 1)';

function onClick() {
    $('body').style.background = BACKGROUND_COLOR
}

$('button').addEventListener('click', onClick)
```



#### 模块化

在以下示例中，所有实现细节都隐藏在立即执行的函数表达式中。函数 `tick` 和 `toString` 关闭它们完成工作所需的私有状态和函数。闭包使我们能够模块化和封装我们的代码

```javascript
let namespace = {}

(function foo(n) {
    let numbers = []
    function format(n) {
        return Math.trunc(n)
    }
    function tick() {
        numbers.push(Math.random() * 100)
    }
    function toString() {
        return numbers.map(format)
    }
    n.counter = {
        tick,
        toString
    }
})(namespace)

const counter = namespace.counter;
counter.tick()
counter.tick()
console.log(counter.toString())
```





### 闭包的延伸

#### 柯里化函数



#### 函数式编程



#### redux-thunk的源码












执行外层函数，外层函数压入执行栈中，调用它时返回一个函数，这个函数被调用着，所以能保持状态（没有释放）

前提：内层函数调用外层函数中的变量。因为使用着外层函数中的变量，所以无法释放

为什么无法释放？执行上下文栈在调用着

闭包住的函数，调用，闭包函数内部的变量变化，调用完后，退出执行上下文栈，此时，内部的变量已经变化了

这也是闭包的特性：改变函数内部的变量







最简单的闭包例子

```javascript
function foo() {
    var a = 2;
    
    function bar() {
        console.log(a);
    }
    
    return bar;
}

var baz = foo();

baz(); // 2 —— 这就是闭包

```



垃圾回收器会释放不在使用的内存空间，

闭包会阻止这件事发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用



这个函数在定义时的词法作用域意外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域



无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包



本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使 用了回调函数，实际上就是在使用闭包





### 图解闭包

我们看这个例子：

```javascript
function foo() {
    var a = 2;
    return function () {
        console.log(a)
    }
}
var bar = foo()
bar()
```

EC：

GlobalContext



变量对象（Varibale Object）：

bar

function foo



执行 `var bar = foo()` ，调用函数 foo()



往栈中push(fooContext) 

EC:

fooContext

GlobalContext



变量对象（Varibale Object）

var a 

function () (匿名函数)

因为JS引擎在代码编译阶段就确定了它的作用域，我们能看到返回的匿名函数，使用了foo()上下文中的变量，所以foo()上下文不能被销毁



以执行上下文中的案例为例，我们稍作修改

```javascript

function foo() {
    var a = 2;
    
    function bar() {
        console.log(a)
    }
    return bar
}
var baz = foo()

baz(); // 2 闭包的效果
```





如果说闭包的概念是 内部函数调用外部函数的变量，那么以下例子中的 `函数bar` 不就是 闭包吗

```javascript
function foo() {
    var a = 1;
    function bar() {
        console.log(a)
    }
    bar()
}
foo()
```

它属于广义上的闭包，但不是我们现实中使用的闭包

这句话（内部函数调用外部函数的变量）不够严谨





以前一说到闭包，很多人都会提到 `作用域链` (Scope Chain) ，同时会引出 VO（变量对象）和AO（活动对象）这些概念。但在这里，我却没怎么提到相关的关键字，这是为什么？因为版本不同，就好像winter在《重学前端》中所说：

直线

执行上下文在ES3中，包含三个部分

- scope：作用域，也常常被叫做作用域链
- variable object：变量对象，用来存储变量的对象
- this value： this值

在ES5中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。 在ES2018中，执行上下文又变成了这个样子，this值被归入lexical environment，但是增加了不少内容。 表达式部分：函数体 scope：作用域，也常常被叫做作用域链。 variable object：变量对象，用于存储变量的对象。 this value：this值。 lexical environment：词法环境，当获取变量时使用。 variable environment：变量环境，当声明变量时使用。 this value：this值。



https://zh.javascript.info/closure

闭包是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后

在 JavaScript 中，所有函数都是天生闭包的

也就是说：JavaScript 中的函数会自动通过隐藏的 `[[Environment]]` 属性记住创建它们的位置，所以它们都可以访问外部变量

通常，闭包是指使用一个特殊的属性`[[Environment]]` 来记录函数自身的创建时的环境的函数。它具体指向了函数创建时的词法环境



### 用案例解释闭包

```javascript
let globalA = 1;
function outer(nonlocalA) {
    console.log(globalA)
    function inner() {
        console.log(nonlocalA)
    }
    return inner
}
let innerA = outer('a')
let innerB = outer('b')
```



调用outer()，意味着往执行上下文栈中压入栈，再生成新的词法环境，其中包含了变量 `nonlocalA`，`console.log`命令，以及 inner 函数。

再往下走，执行 `console.log(nonlocalA)`，再往执行上下文栈中压入，执行完之后释放

走到 function inner 函数时，因为 JavaScript 的作用域是词法作用域，所以它

最后返回 inner 函数

注意了，**在函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数**（参考[词法作用域章](./词法环境.md)）











早期的闭包由`环境（执行环境、标识符列表）与表达式` 两部分组成

环境部分正好对应执行上下文中的词法环境与标识符列表

表达式部分则对应了JS中的函数体



所谓闭包其实就是一个自带了执行环境（由外层函数提供，即便外层函数销毁依旧可以访问）的特殊函数



```javascript
fContext = {
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
}
```

所以指向关系是当前作用域 --> `checkscope`作用域--> 全局作用域，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO（活动对象） 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，这就是闭包实现的**关键**。



即使上下文销毁了也没事，因为作用域会





每个方法（函数）在执行的时候都会创建一个新的执行上下文，同事也会创建它们自己的词法环境，每个方法的词法环境里有一个 `scope` 会保存（执行）它上一层的词法环境





词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系



闭包是静态作用域的自然延伸

因为我们用的是词法作用域，

你返回一个函数，但是我的作用域已经保存了参数

内部函数可以访问它们外部函数 foo 中的变量





真实的数据背存在该函数内部，该函数会再暴露除一个函数用来访问真实的数据

闭包有什么用？

闭包一方面存储 name、age 和 title，一方面让 temp 函数去操作这些变量，这就是闭包的全部作用



闭包是穷人的对象，对象是穷人的闭包





**「函数」和「函数内部能访问到的变量」（词法环境）的总和，就是一个闭包**

闭包是 JS 函数作用域的副产品

换句话说，正是由于 JS 的函数内部可以使用函数外部的变量，所以这段代码正好符合了闭包的定义。而不是 JS 故意要使用闭包









### 参考资料： 

[说说我对JavaScript 闭包的理解](https://juejin.im/post/5a65cfa4f265da3e377c2491)

[变量作用域，闭包](https://zh.javascript.info/closure)

[大部分人都会做错的经典JS闭包面试题](https://www.cnblogs.com/xxcanghai/p/4991870.html)

[how-do-javascript-closures-work](https://stackoverflow.com/questions/111102/how-do-javascript-closures-work)

[JS 中的闭包是什么？](https://fangyinghang.com/closures-in-js/)