# 闭包



### 前言：

网络中有各种各样说闭包的文章，有些浅尝辄止，有些CV党，又有些只讲一部分。对我而言，要想了解闭包，需要掌握的知识点有 `词法环境(或者是ES中的变量对象)` 、`执行上下文与执行栈` 、 `(词法)作用域` 、 `作用域链` 等等。

好在我们在之前的已经梳理了这几块的内容：[词法作用域](./作用域.md)、[词法环境](./词法环境.md)、[执行上下文](./执行上下文与调用栈.md) 。接下来让我们揭开闭包的面纱，从外到内认清克利奥帕特拉七世（闭包）



### 一句话解释：



### 为什么要有闭包？

在讲闭包之前，我们不妨问自己一下，为什么会有它（这个概念），它解决了什么问题？

试想一下以下场景。你实现一个 web 应用，写了很多页面，同样引入了一些库和框架，自己又写了很多工具函数，当他们在一个（全局）作用域下，就会引发变量冲突问题（虽然我们强调命名规范问题，但实际开发总会遇到命名相同等问题）

假设你定义了一个变量a，一个函数b，直接写在全局环境下，这个模块实现了功能A。现在我们的程序需要开发功能B，你也想用变量a，函数b标识符来表示，那就尴尬了，因为已经在功能A上使用过，不能再使用，而如果不用变量a和函数b标识符来表示语义化上又不洽淡。

你也许想到了c、d两个名字，但是当你调试时，发现原来这两个标识符也已经被其他的工具函数使用过。

命名冲突的原因是因为 **同作用域下已存在相同的变量名**，要解决以上问题，就要从作用域上下手，

即——**一个模块应该有自己的作用域，来保证模块的正常运行**

全局作用域肯定不行，我们只用函数作用域可以实现这一功能。所以**闭包其实是利用了函数作用域实现的一种变量保护机制**

它的作用是**对模块中变量的保护**。即在函数作用域中写好代码后，将要使用的变量 return 语句暴露到外界

```javascript
function outer() {
    var a = '私有变量，只能在 outer 中使用';
    function inner() {
        console.log('我是 outer 中的私有函数，只能在 outer 中使用')
    }
    function closureOuter() {
        inner()
        console.log(a)
    }
    return closureOuter
}

var bar = outer()
bar()
// 我是 outer 中的私有函数，只能在 outer 中使用
// 私有变量，只能在 outer 中使用
```

我们以这个 demo 为例，来说一说整个过程。因为词法作用域，外层函数不能访问内层函数的变量。所以函数 `outer` 外不能使用 `outer` 内的变量 `a` 和函数 `inner`。但是如果我们调用函数 `outer` 时赋值给 `bar` ，返回的是函数 `outer` 内的函数 `closureOuter` ，此时的 `bar` 指向函数  `closureOuter` ，函数 `closureOuter` 因为词法环境的原因，能访问变量 `a` 和函数 `inner` 。当调用 `bar` 时，执行函数 `clousureOuter` ，执行 `inner` 和打印变量 `a` 

我们也可以这样理解，`outer` 就是一个模块，它暴露 `closureOuter`  给外界，外界调用 `outer` 模块，能使用 `outer` 的变量，但是不能对内部的变量做修改（保护变量）

回到开头所说，为什么要有闭包，因为只有使用闭包才能实现对变量的保护，**闭包其实是一个绑定了执行环境（执行上下文）的函数**



### 各路大神对闭包的定义：

winter：

> 闭包其实只是一个绑定了执行环境的函数
>
> 闭包与普通函数的区别是，它携带了执行环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境
>
> 实际上 JavaScript 中跟闭包对应的概念就是“函数”

候策

> 函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可访问，就形成了闭包。

黑客与画家

> 闭包（lexical closure） 一个函数，通过它可以引用由包含这个函数的代码所定义的变量

神三元

> 闭包产生的本质就是，当前环境中存在指向父级作用域的引用

MDN对闭包的定义为：

> 闭包时指哪些能够访问自由变量的函数

那什么是自由变量呢？

> 自由变量是指在函数中使用的，但既不是函数参数也不是函数局部变量的变量

由此，我们可以看出闭包共又两部分组成

> 闭包 = 函数 + 函数能够访问的自由变量

 《你不知道的 JavaScript》 

> 闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。



### 闭包形成的原理

闭包的本质是利用函数作用域保护自由变量，并且返回了对被保护变量的引用，这种行为就是闭包

我们先快速复习一下这三个知识点：[词法作用域](./作用域.md)、[词法环境](./词法环境.md)、[执行上下文](./执行上下文与调用栈.md) 。

词法作用域：词法作用域就是定义在词法阶段的作用域

词法环境：在代码编译阶段记录变量声明、函数声明、函数声明形参的合集？

执行上下文：调用函数时所带的所有信息

```javascript
function foo() {
    var a = 1;
    function bar() {
        console.log(a++)
    }
    bar()
}
foo()
```



```javascript
function foo() {
    var a = 1;
    return function bar() {
        console.log(a++)
    }
}
var baz = foo()
baz()
```











### 闭包的用途及应用场景

用途：即重用一个变量，又保护变量不被污染的一种编程方法

闭包的应用场景：（1）函数作为返回值；（2）函数作为参数传递

主要到没有，无论是函数作为返回值，还是函数作为参数传递，本质都是函数在预编译时生成作用域，而只要这个函数使用了函数外的变量，调用完外层函数后，没有弹出执行上下文栈





就像上文中介绍，闭包是为了解决私有变量

在 ES6 的 class 没有之前，JavaScript只能借助闭包，在函数中赋值变量，并返回带有变量的函数，举个例子：

```javascript
function counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}
var c1 = counter();
c1.inc() // 1
c1.inc() // 2
c1.inc() // 3

var c2 = counter(10);
c1.inc() // 11
c1.inc() // 12
c1.inc() // 13
```

在返回的对象中，实现了一个闭包，该闭包携带了局部变量`x` ，并且外部代码根本无法范文到变量`x` 。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏。





### 闭包在函数式编程中的应用

设计闭包（Closure）的初衷是为了解决什么问题？

闭包是函数式编程及其核心思想“Lambda 计算法”（Lambda Calculus）的必备基础设定

闭包能做什么？

https://juejin.im/post/6844903769646317576#heading-10







#### 利用闭包实现“模块化” 

有何高见



### 闭包的延伸

#### 柯里化函数



#### 函数式编程



#### redux-thunk的源码












执行外层函数，外层函数压入执行栈中，调用它时返回一个函数，这个函数被调用着，所以能保持状态（没有释放）

前提：内层函数调用外层函数中的变量。因为使用着外层函数中的变量，所以无法释放

为什么无法释放？执行上下文栈在调用着

闭包住的函数，调用，闭包函数内部的变量变化，调用完后，退出执行上下文栈，此时，内部的变量已经变化了

这也是闭包的特性：改变函数内部的变量







最简单的闭包例子

```javascript
function foo() {
    var a = 2;
    
    function bar() {
        console.log(a);
    }
    
    return bar;
}

var baz = foo();

baz(); // 2 —— 这就是闭包

```



垃圾回收器会释放不在使用的内存空间，

闭包会阻止这件事发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用



这个函数在定义时的词法作用域意外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域



无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包



本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使 用了回调函数，实际上就是在使用闭包





### 图解闭包

我们看这个例子：

```javascript
function foo() {
    var a = 2;
    return function () {
        console.log(a)
    }
}
var bar = foo()
bar()
```

EC：

GlobalContext



变量对象（Varibale Object）：

bar

function foo



执行 `var bar = foo()` ，调用函数 foo()



往栈中push(fooContext) 

EC:

fooContext

GlobalContext



变量对象（Varibale Object）

var a 

function () (匿名函数)

因为JS引擎在代码编译阶段就确定了它的作用域，我们能看到返回的匿名函数，使用了foo()上下文中的变量，所以foo()上下文不能被销毁



以执行上下文中的案例为例，我们稍作修改

```javascript

function foo() {
    var a = 2;
    
    function bar() {
        console.log(a)
    }
    return bar
}
var baz = foo()

baz(); // 2 闭包的效果
```





如果说闭包的概念是 内部函数调用外部函数的变量，那么以下例子中的 `函数bar` 不就是 闭包吗

```javascript
function foo() {
    var a = 1;
    function bar() {
        console.log(a)
    }
    bar()
}
foo()
```

它属于广义上的闭包，但不是我们现实中使用的闭包

这句话（内部函数调用外部函数的变量）不够严谨





以前一说到闭包，很多人都会提到 `作用域链` (Scope Chain) ，同时会引出 VO（变量对象）和AO（活动对象）这些概念。但在这里，我却没怎么提到相关的关键字，这是为什么？因为版本不同，就好像winter在《重学前端》中所说：

直线

执行上下文在ES3中，包含三个部分

- scope：作用域，也常常被叫做作用域链
- variable object：变量对象，用来存储变量的对象
- this value： this值

在ES5中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。 在ES2018中，执行上下文又变成了这个样子，this值被归入lexical environment，但是增加了不少内容。 表达式部分：函数体 scope：作用域，也常常被叫做作用域链。 variable object：变量对象，用于存储变量的对象。 this value：this值。 lexical environment：词法环境，当获取变量时使用。 variable environment：变量环境，当声明变量时使用。 this value：this值。



https://zh.javascript.info/closure

闭包是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后

在 JavaScript 中，所有函数都是天生闭包的

也就是说：JavaScript 中的函数会自动通过隐藏的 `[[Environment]]` 属性记住创建它们的位置，所以它们都可以访问外部变量

通常，闭包是指使用一个特殊的属性`[[Environment]]` 来记录函数自身的创建时的环境的函数。它具体指向了函数创建时的词法环境



### 用案例解释闭包

```javascript
let globalA = 1;
function outer(nonlocalA) {
    console.log(globalA)
    function inner() {
        console.log(nonlocalA)
    }
    return inner
}
let innerA = outer('a')
let innerB = outer('b')
```

let innerA = outer('a') 是有两个动作

一、调用outer('a')

二、将outer('a') 的结果赋值给 innerA

先来看第一个动作

调用outer()，意味着往执行上下文栈中压入栈，这个栈中有变量 nonlocalA，打印 globalA，并返回inner函数

注意了，这里已经生成了inner词法环境（参考词法作用域章，简单的说，词法环境是在创建阶段被创建出的），但是











### 参考资料： 

[说说我对JavaScript 闭包的理解](https://juejin.im/post/5a65cfa4f265da3e377c2491)

