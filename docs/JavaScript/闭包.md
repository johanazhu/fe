# 闭包



网络中有各种各样说闭包的文章，有些浅尝又止，有些CV党，又有些枯燥无味，还有版本不统一，有些说词法环境，有些说作用域链，有些说

闭包关联的东西太大，虽然只是一个概念，但与之关联的有 `词法环境` 、`执行上下文`、`执行栈` 、 `作用域` 、 `作用域链` 、`VO/AO` 、`this` 等等



### 为什么要有闭包？

我们去了解一个概念时，如果先问一句，为什么会有它（这个概念），往往很多东西就能不攻自破

为什么会有闭包，它产生的原因是什么，又解决了什么？

我们不妨试想一下以下场景。你实现一个 web 应用，写了很多页面，同样引入了一些库和框架，自己又写了很多工具函数，当他们在一个（全局）作用域下，就会引发变量冲突问题（虽然我们强调命名规范问题，但实际开发总会遇到命名相同等问题）

假设你定义了一个变量a，一个函数b，直接写在全局环境下，这个模块实现了功能A。

现在我们的程序需要开发功能B，你也想用变量a，函数b标识符来表示，那就尴尬了，因为已经在功能A上使用过，不能再使用，而如果不用变量a和函数b标识符来表示语义化上又不洽淡。

你也许想到了c、d两个名字，但是当你调试时，发现原来这两个标识符也已经被其他的工具函数使用过。

命名冲突的原因是因为 **同作用域下已存在相同的变量名**，要解决以上问题，就要从作用域上下手

即——**一个模块应该有自己的作用域，来保证模块的正常运行**

全局作用域肯定不行，我们只用函数作用域可以实现这一功能。SO 我们要讲的闭包本质上就是一个函数作用域

它的作用是**对模块中变量的保护**。即在函数作用域中写好所有流程后，将要使用的变量return语句暴露到外界

```javascript
function foo() {
    var a = '我是 foo 的私有变量，只能在 foo 中使用';
    function b() {
        console.log('我是 foo 中的私有函数，只能在 foo 中使用')
    }
    function closuresab() { // 将 foo 中的私有变量打包到 closuresab 中
        b();
     	console.log(a)   
    }
    return closuresab
}
var bar = foo()
bar() 
// 我是 foo 中的私有函数，只能在 foo 中使用
// 我是 foo 的私有变量，只能在 foo 中使用
```

这让我们在全局中调用bar()，来得到函数内的变量

这就是闭包的作用。**闭包其实只是一个绑定了执行环境（执行上下文）的函数**

#### 我的理解

因为作用域是词法作用域，函数内定义的变量函数外不能使用。如果我想调用函数内的变量呢？怎么办？返回使用函数内部变量的函数，这样即使这个调用完这个父层函数，子函数也能以闭包的形式继续存留下来，作用上下文释放不了，这就是闭包的原因

```javascript
function foo(){
    var a = 2; // 私有变量，属于 foo
    return function() { // 返回一个匿名函数，匿名函数中调用a
        a++
        console.log(a)
    }
}
var bar = foo() // 将 foo 函数赋值给 bar
bar() // 3
bar() // 4
```

如上所示，我明明在函数外面，却能调用了函数里面的变量。我们再来个例子

```javascript
function foo(){
    return function(name) { // 返回一个回调函数
        console.log(name)
    }
}
var bar = foo() // 将 foo 函数赋值给 bar
bar('elaine') // elaine
```

是不是很熟悉，回调函数竟然是闭包



Jquery 中有大量的回调函数例子：

```javascript
function setupBot(name, selector) {
    $(selector).click(function() {
        console.log('调用', name)
    })
}
setupBot('closure Bot 1', '#bot1')
setupBot('closure Bot 2', '#bot2')
```

我们可以得出这样的结论：只要使用了**回调函数**，实际上就是在使用闭包！



闭包的原理也相对简单，本质是函数作用域的作用，其概念是：利用函数作用域保护自由变量，并且返回了对被保护变量的引用，这种行为就是闭包。

闭包无处不在，比如我们熟悉的回调函数，只要使用了就自然有闭包。

既能使用局部变量，又不污染全局





深入javascript——作用域和闭包

https://segmentfault.com/a/1190000000618597



用途：即重用一个变量，又保护变量不被污染的一种编程方法





#### 闭包

什么是：即重用一个变量，又保护变量不被篡改的一个机制

为什么会有它

​	全局变量： 优：可重用

​						缺：造成全局污染，易被篡改

​	局部变量： 优：仅函数内可使用，不会污染全局，也不会被篡改

​						缺：不可重用

何时：只要希望重用一个变量，又保护变量不被污染

闭包的题目很多
hook也是用了闭包的机制
要多写一些案例

react hooks 中有闭包陷阱

被压着释放不了



### 各路大神对闭包的定义：

winter：

> 闭包与普通函数的区别是，它携带了执行的环境
>
> 闭包其实只是一个绑定了执行环境的函数
>
> 闭包与普通函数的区别是，它携带了执行环境，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境
>
> 实际上JavaScript中跟闭包对应的概念就是“函数”
>

候策

> 函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可访问，就形成了闭包。

无名氏

> 闭包是为了达到某种目的而实现的技术，其原理是利用javascript的作用域。javascript的作用域是词法作用域，与在哪里定义有关（与在哪里调用无关）。所以你在一个函数中定义变量，再返回带有此变量的函数，暴露出去是，变量不会随着调用完毕而被垃圾回收回收，这就是闭包
>

黑客与画家

> 闭包（lexical closure） 一个函数，通过它可以引用由包含这个函数的代码所定义的变量

神三元

> 闭包产生的本质就是，当前环境中存在指向父级作用域的引用

MDN对闭包的定义为：

> 闭包时指哪些能够访问自由变量的函数

那么什么是自由变量呢？

> 自由变量是指在函数中使用的，但既不是函数参数也不是函数局部变量的变量

由此，我们可以看出闭包共又两部分组成：

> 闭包 = 函数 + 函数能够访问的自由变量

就像 《你不知道的 JavaScript》 中讲的：

> 闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意 识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿 来识别、拥抱和影响闭包的思维环境。



在编程语言中，闭包表示一种函数
闭包其实是一个绑定了执行环境的函数



闭包，作用域的引用导致的结果

### 闭包形成的原理

在讲闭包形成原理之前，我们需要知道三个知识点：[执行上下文](./执行上下文与执行栈.md)、[词法环境](./词法环境.md)、[词法作用域](./作用域.md) 。



闭包就是 执行上下文没有销毁（原因：作用域链），占内存，作用：函数外操作函数内的变量



当代码要访问一个变量时——首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。

无论函数在何处调用，可用的变量总是包括“定义该函数时的可用变量”



### 闭包的应用场景：

闭包的应用场景：（1）函数作为返回值；（2）函数作为参数传递

主要到没有，无论是函数作为返回值，还是函数作为参数传递，本质都是函数在预编译时生成作用域，而只要这个函数使用了函数外的变量，调用完外层函数后，没有弹出执行上下文栈





就像上文中介绍，闭包是为了解决私有变量

在ES6的class没有之前，JavaScript只能借助闭包，在函数中赋值变量，并返回带有变量的函数，举个例子：

```javascript
function counter(initial) {
    var x = initial || 0;
    return {
        inc: function () {
            x += 1;
            return x;
        }
    }
}
var c1 = counter();
c1.inc() // 1
c1.inc() // 2
c1.inc() // 3

var c2 = counter(10);
c1.inc() // 11
c1.inc() // 12
c1.inc() // 13
```

在返回的对象中，实现了一个闭包，该闭包携带了局部变量`x` ，并且外部代码根本无法范文到变量`x` 。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏。





### 闭包在函数式编程中的应用

设计闭包（Closure）的初衷是为了解决什么问题？

闭包是函数式编程及其核心思想“Lambda 计算法”（Lambda Calculus）的必备基础设定

闭包能做什么？

https://juejin.im/post/6844903769646317576#heading-10







闭包：函数外部可以控制函数内部的变量



```javascript
function foo() {
    var x = 10;
    function bar() {
        console.log(x)
    }
    return bar
}
var x = 20;
foo()()
```

产生闭包的原因，作用域

因为javascript是词法作用域，在哪里定义作用域就作用于哪里，bar在foo的作用域中，当调用foo()，返回的是函数 bar，再调用foo()()，即bar()，打印x，因为bar在作用域foo中，所以当x自由变量在bar函数中找不到变量时，迎着作用域链往上走，就到了foo，找到变量x= 10，那就能打印出 x = 10

如果我们将foo函数中的`var x = 10;`删掉，

```javascript
function foo() {
    function bar() {
        console.log(x)
    }
    return bar
}
var x = 20;
foo()()
```

你觉得会打印什么？

x = 20

为什么？

迎着作用域往上找，找不到才会报错，但是全局作用域中有x，就打印出x

另外，我这里有一个疑问，使用`foo()()`，debugger时没有看到闭包，但是先给foo() 赋值，再调用它会看到闭包





#### 利用闭包实现“模块化” 

有何高见



### 闭包的延伸

#### 柯里化函数



#### 函数式编程



#### redux-thunk的源码
















如果要理解闭包。需要提前了解几个知识点。因为闭包不是一个单一的概念，它是由作用域、作用域链、执行上下文、调用栈、内存管理等多重知识相结合的概念

之前我们讲过作用域。简单来说，作用域分三种，一是全局作用域，二是函数作用域。三是块级作用域。函数内部能调用函数外部的变量。函数定义时，即产生了作用域链

块级作用域和暂时性死区。

之前的var变量，会有变量提升的概念。即你在任何处用var定义变量，一开始会js引擎会将其变量置位顶部（以 `undefined` 的形式，再执行到赋值时，再赋值）

但是用let、const 声明的变量，则不会有变量提升的概念，在定义let之前，不能调用let声明的变量，不然会报错，在块级作用域的开始到let声明的前一行，这块区域被称为`暂时性死区`





之前我们说了 this、词法环境、作用域链以及执行上下文和调用栈，现在将它们整合到一起，就明白了闭包是怎么回事

集合：

**作用域在预编译阶段确定，但是作用域链是在执行上下文的创建阶段完成生成的**。因为函数在调用时，才会开始创建对应的执行上下文。执行上下文包括了：变量对象、作用域链以及 `this` 的指向







```javascript
function makeCounter() {
    let count = 0;
    return function () {
        return count++
    }
}

let counter = makeCounter()
```

我们在执行 `makeCounter()` 的过程中创建了一个仅占一行的嵌套函数：`return counter++ ` 。我们尚未运行它，仅创建了它。

所有的函数在“诞生”时都会记住创建它们的词法环境。从技术上讲，这里没有什么魔法：所有函数都有名为 `[[Environment]]` 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。









从实践角度：以下函数才算是闭包：

1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
2. 在代码中引用了自由变量



看到 `function` 应该想到什么，创建新函数 







执行外层函数，外层函数压入执行栈中，调用它时返回一个函数，这个函数被调用着，所以能保持状态（没有释放）

前提：内层函数调用外层函数中的变量。因为使用着外层函数中的变量，所以无法释放

为什么无法释放？执行上下文栈在调用着

闭包住的函数，调用，闭包函数内部的变量变化，调用完后，退出执行上下文栈，此时，内部的变量已经变化了

这也是闭包的特性：改变函数内部的变量







> 



最简单的闭包例子

```javascript
function foo() {
    var a = 2;
    
    function bar() {
        console.log(a);
    }
    
    return bar;
}

var baz = foo();

baz(); // 2 —— 这就是闭包

```



垃圾回收器会释放不在使用的内存空间，

闭包会阻止这件事发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用



这个函数在定义时的词法作用域意外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域



无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包



本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使 用了回调函数，实际上就是在使用闭包





### 图解闭包

我们看这个例子：

```javascript
function foo() {
    var a = 2;
    return function () {
        console.log(a)
    }
}
var bar = foo()
bar()
```

EC：

GlobalContext



变量对象（Varibale Object）：

bar

function foo



执行 `var bar = foo()` ，调用函数 foo()



往栈中push(fooContext) 

EC:

fooContext

GlobalContext



变量对象（Varibale Object）

var a 

function () (匿名函数)

因为JS引擎在代码编译阶段就确定了它的作用域，我们能看到返回的匿名函数，使用了foo()上下文中的变量，所以foo()上下文不能被销毁



以执行上下文中的案例为例，我们稍作修改

```javascript

function foo() {
    var a = 2;
    
    function bar() {
        console.log(a)
    }
    return bar
}
var baz = foo()

baz(); // 2 闭包的效果
```





如果说闭包的概念是 内部函数调用外部函数的变量，那么以下例子中的 `函数bar` 不就是 闭包吗

```javascript
function foo() {
    var a = 1;
    function bar() {
        console.log(a)
    }
    bar()
}
foo()
```

它属于广义上的闭包，但不是我们现实中使用的闭包

这句话（内部函数调用外部函数的变量）不够严谨





以前一说到闭包，很多人都会提到 `作用域链` (Scope Chain) ，同时会引出 VO（变量对象）和AO（活动对象）这些概念。但在这里，我却没怎么提到相关的关键字，这是为什么？因为版本不同，就好像winter在《重学前端》中所说：

直线

执行上下文在ES3中，包含三个部分

- scope：作用域，也常常被叫做作用域链
- variable object：变量对象，用来存储变量的对象
- this value： this值

在ES5中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。 在ES2018中，执行上下文又变成了这个样子，this值被归入lexical environment，但是增加了不少内容。 表达式部分：函数体 scope：作用域，也常常被叫做作用域链。 variable object：变量对象，用于存储变量的对象。 this value：this值。 lexical environment：词法环境，当获取变量时使用。 variable environment：变量环境，当声明变量时使用。 this value：this值。

























问面试官问题：

我想问一个关于闭包的问题，

如果闭包，调用完引发闭包的外层函数后，它释放了外层函数，而因为闭包，那么没有被引用的变量会释放，被引用的变量会被存在哪里？

存在闭包对象中

被闭包住的函数，当他执行完后会一直存在在执行上下文栈中吗

























### 参考资料： 

[说说我对JavaScript 闭包的理解](https://juejin.im/post/5a65cfa4f265da3e377c2491)

