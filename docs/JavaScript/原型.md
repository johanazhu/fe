# 原型

原型的本质就是 一个家族史的变迁

这让我想起了《百年孤独》，一族六代人的家族故事。我至今还记得书中的一句话：
家族的第一个人被绑在树上，家族的最后一个人被蚂蚁咬死。

这很原型链



先说结论：

原型（prototype）是给其他对象提供共享属性的对象。

所有 object 对象都有一个隐式引用





### 1.什么是原型

ES2019 （https://www.ecma-international.org/ecma-262/10.0）是当前最新的语言规范，可以作为我们理解 JS 原型的权威素材来源。

我们先从规范开始，看看里面如何介绍 Prototype。

**1.1、prototype 的定义**

> 4.3.5 prototype 
>
> object that provides shared properties for other objects

在规范里，prototype 被定义为：给其他独享提供共享属性的对象。

也就是说，prototype 自己也是对象，只是被用来承担某个职能罢了。

prototype 只是其中一种划分，我们也可以按照自己的需求，给出不同的划分和命名

比如实现 pubsub pattern 订阅/发布模式时，我们将某个对象称之为 subscriber 订阅者，另一个对象称之为 publisher 发布者。

构造函数的首字母为大写

都只是一个约定，约定俗成。

同理，当某个对象，承担了**为其他对象提供共享属性**的职责时，它就成了该对象的 prototype。当它失去这个职能（比如子对象的原型被设置为其他对象），它就不叫该对象的 prototype。

换句话说，当我们说 prototype 对象时，是在做一个简略描述，实际上说的是“XXX 对象的 prototype对象”。如果不跟其他对象产生关联，就不构成 prototype 这个称谓。

因此，prototype 描述的是两个对象之间的某种关系（其中一个为另一个提供属性访问权限）。它是类型 father 父亲一样的称谓，而不是具有超能力的异常对象。

所有对象，都可以作为另一个对象的 prototype 来用。

##### 1.1.1、所有 object 对象都有一个隐式引用

> Every object has an implicit reference (called the object's prototype)

如上，规范中明确描述了所有对象，都有一个隐式引用，它被称之为这个对象的 prototype 原型。

什么叫隐式引用？

![1595849127292](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1595849127292.png)

如上图所示，在我们编写的代码里，只声明了 obj 对象的 a 和 b 两个属性。

在控制台却可以发现它有 `__proto__` 属性，这意味着 obj 被隐式地挂载了另一个对象的引用，置于 `__proto__` 属性中。

也就是说，所谓的隐式，是指不是由开发者亲自创建/操作。

##### 1.1.2、历史问题：`__proto__`

前面措辞里“隐式地挂载引用”，这跟规范里描述的“隐式引用”，有一定的差别。

它们是两个维度。

一个是在操作层面上的隐式：是否偷偷做了挂载属性的动作。

一个是在关系层面上的隐式：这个属性能不能被直接访问。

`__proto__` 的例子，说起来比较复杂，可以说是一个历史问题。

ECMAScript 规范描述 prototype 是一个隐式引用，但之前的一些浏览器，已经私自实现了 `__proto__` 这个属性，使得可以通过 ` obj.__proto__ ` 这个显式的属性访问，访问到被定义为隐式属性的 prototype。

因此，情况是这样的，ECMAScript 规范说 prototype 应当是一个隐式引用:

1）通过 Object.getPrototypeOf(obj) 间接访问指定对象的 prototype 对象。

2）通过 Object.setPrototypeOf(obj, anotherObj) 间接设置指定对象的 prototype 对象。

3）部分浏览器提前开了 `__proto__` 的口子，使得可以通过 `obj.__proto__ `直接访问原型，通过 `obj.__proto__ = anotherObj` 直接设置原型。

4）ECMAScript 2015 规范只好向事实低头，将 `__proto__` 属性纳入了规范的一部分。

![原型proto历史](D:\code\project\elaine\fe\docs\.vuepress\public\images\JavaScript\原型proto历史.png)

在 Object.prototype 上有 `__proto__` 属性，不过在你chrome中看到的`__proto__` 属性则是开发者工具为了方便开发者查看原型，故意渲染出来的虚拟节点。虽然与对象的其它属性并列，但并不在改对象中（如下图）

![原型proto](D:\code\project\elaine\fe\docs\.vuepress\public\images\JavaScript\原型proto.png)

`__proto__` 属性既不能被 for in 比那里出来，也不能被 Object.keys(obj) 查找出来

访问对象的 `obj.__proto__` 属性，默认走的是 Object.prototype 对象上的 `__proto__` 属性的get/set 方法。

![改变proto的值](D:\code\project\elaine\fe\docs\.vuepress\public\images\JavaScript\改变proto的值.png)

通过覆盖 `Object.prototype.__proto__` 我们可以看到，访问普通对象的`__proto__`触发了 Object.prototype 上的`__proto__` 的 get 方法



**1.2、对象的创建和关联原型**

许多介绍 JS 原型的文章，都从 constructor 构造函数和 prototype 入手。本文并没有这样做。

因为 prototype 的概念，跟对象的构造方式和原型关联方式，其实是两个问题。

JavaScript 只是其中一个 prototype-based inheritance 的语言，其它同样包含 prototype 概念的语言，并不像 JS 那样通过 constructor 和 prototype 构造对象和关联其原型。

因此，当我们谈论 prototype 时，它可以跟 constructor 和 constructor.prototype 无关。

**1.2.1、两类原型继承方式**

所谓的原型继承，就是指设置某个对象为另一个对象的原型（塞进该对象的隐式引用位置）。

在 JavaScript 中，有两类原型继承的方式：显式继承和隐式继承。

**1.2.1.1、显式原型继承**

在前文我们曾描述过显示跟隐式的差别：是否由开发者亲自操作





JavaScript 分为基本类型和引用类型。引用类型皆为对象。对象又分为 `函数对象` 和 `普通对象`。其中 String，Number，Boolean，Object，Function，Array，Date，RegExp，Error

这些都是函数对象，他们同时也被称为 **内置对象**。函数对象本身是一个纯函数，JavaScript用它们来模拟类。普通对象就很简单了。就是常见的对象。

虽然我们这么说，但具体的 `函数对象` 是什么，我们看几个例子

```javascript
const a = {}
const b = new Object()
function c() {}
const d = new func1()
const e = new function(){}
const f = new Function()
const g = new Array()
const h = []
```

答案：

```javascript
console.log(typeof a)	// object
console.log(typeof b)	// object
console.log(typeof c)	// function
console.log(typeof d)	// object
console.log(typeof e)	// object
console.log(typeof f)	// function
console.log(typeof g)	// object
console.log(typeof h)	// object
```

我们之前的文章中也检测过内置函数，可以看xxxxx这里

大致来说，实例化后的值为 普通对象，构造函数（内置函数也属于构造函数）则是"函数对象"



前置知识掌握的差不多了，现在来



只有函数对象有 prototype（可以把它理解成props） 属性，普通对象没有这个属性，

new 的时候语言本身帮你绑定了 prototype，

就好比对中国人来说，春节是个喜庆的日子，是过年休息的日子，这是我们的传统，也是惯性的作用，让每个人一到春节就会想到回家过年。

当你 new 的时候，语言就帮你加上了 prototype（props）属性，是自带的，不以人的意志而转移。

所以 prototype（props）被称为隐式引用

至于 `__proto__` ，每一个对象都有，这也是语言自带的。但`__proto__` 的历史背景有点意思，他本身是没有的，浏览器厂商们为了便利开发者开发程序，特意加上的一个属性

prototype(props)和 `__proto__` 都是在创建一个函数或者对象时自动生成该属性







实例的 `__proto__` 属性指向构造函数的 prototype

`prototype` 属性被 `__prototype` 属性所指向



`prototype` 又被称为显示原型对象，而`__proto__`又被称为隐式原型对象























javascript 语言精粹

每一个对象都连接到一个原型对象，并且它可以从中继承属性。所有通过对象字面量创建的对象都连接到 Object.prototype，它是 JavaScript 中的标配对象

原型连接只有在检索值的时候才被用到。如果我们尝试去获取对象的某个属性值，但该对象没有此属性名，那么 JavaScript 会试着从原型对象中获取属性值。如果那个原型对象也没有该属性，那么再从它的原型中寻找，依次类推，知道该过程最后到达终点 Object.prototyoe。如果想要的属性完全不存在于原型链中，那么结果就是 undefined 值。这个过程称为委托

原型关系是一种动态的关系。如果我们添加一个新的属性到原型中，该属性会立即对所有基于原型创建的对象可见



在 JavaScript 中，每个构造函数都拥有一个 `prototype` 属性，它指向构造函数的原型对象，这个原型对象中有一个 constructor 属性指回构造函数；每个势力都有一个 `__proto__` 属性，当我们使用构造函数去创建实例时，实例的 `__proto__` 属性就会指向构造函数的原型对象





制造者







在规范里， prototype 被定义为：给其它对象提供共享属性的对象



prototype 描述的是两个对象之间的某种关系（其中一个，为另一个提供属性访问权限）



这意味着 obj 被隐式地挂载了另一个对象的引用，置于 `__proto__` 属性中。也就是说，所谓的隐式，是指不是由开发者（你和我）亲自创建/操作。



ECMAScript 规范描述 prototype 是一个隐式引用，但之前的一些浏览器，已经私自实现了 `__proto__` 这个属性，使得可以通过 `obj.__proto__` 这个显式的属性访问，访问到被定义为隐式属性的 prototype 。



在chrome中看到的`__proto__` 属性。实际上，它只是开发者工具为了方便让开发者查看原型，故意渲染出来的虚拟节点。虽然跟对象的其他属性并列，但并不在该对象中。

`__proto__` 属性既不能被 for in 遍历出来，也不能被 Object.keys(obj) 查找出来

访问对象的 `obj.__proto__` 属性，默认走的是 Object.prototype 对象上`__proto__` 属性的 get/set 方法。

```javascript
Object.defineProperty(Object.prototype, '__proto__', {
    get() {
        console.log('get')
    }
})
({}).__proto__

```

通过覆盖 `Object.prototype.__proto__` 我们可以看到，访问普通对象的`__proto__`触发了 `Object.prototype` 上的 `__proto__` 的 get 方法

因此，普通对象创建时，只需要将它内部的隐式引用指向 `Object.prototype` 对象，就能兼容 `__proto__` 属性访问行为，不需要将原型隐式挂载到对象的 `__proto__` 属性



所谓的显示原型继承，就是指我们亲自将某个对象设置为另一个对象的原型。



constructor  —— 构造函数



JavaScript 的主流继承方式，选择了隐式原型继承，它提供了几个内置的 constructor 函数，如 Object，Array，Boolean，String，Number等



当我们使用对象字面量创建一个新对象时，它有两层隐式行为。

（1）隐式的通过 new Object() 去创建对象

（2）隐式的进行原型继承



可以说，JS 原型之所以难以理解，主要原因是设计上的问题，而非技术难度。

如果将 constructor 函数的 prototype 改名为 properties 。问题可能少很多。或者进一步简写成 props，理解上将更加简单。不就是 new Constructor 时，自带了它的 Constructor.props 对象嘛



从 class 角度理解 prototype

class 的职责是充当创建 object 的模板，通常来说， data 数据是由 instance 承载，而 methods 行为/方法则在class里

也就是说，基于 class 的继承，继承的是行为和结构，但没有继承数据。

而基于 prototype 的继承，可以继承数据、结构和行为三者

这是因为，prototype 无非是另一个对象，它跟其他对象一样，拥有自由的非函数属性（数据）和函数属性（方法）

作为对象的 prototype ，不仅可以被继承，还能被当作值传递，它跟其它普通对象，并没有不同



在 JS 里， class 是用 prototype 所模拟的，为了迎合 class 的基本行为。prototype 继承数据的能力被屏蔽了。



JS prototype 原型对应的数据结构和算法是什么？

JS 原型其实是一个隐式的单向链表



所有的属性和方法，都是不可靠的，它们很容易通过原型继承后，加以篡改



很多年前，整个前端开发社区就达到了高度的共识，如无必要，不要随意往原型上拓展方法，特别是全局构造函数里的原型。







ECMAScript 规范描述 `prototype` 是一个隐式引用，但之前的一些浏览器，已经私自实现了 `__proto__`这个属性，使得可以通过 `obj.__proto__` 这个显式的属性访问，访问到被定义为隐式属性的 `prototype`。

因此，情况是这样的，ECMAScript 规范说 `prototype` 应当是一个隐式引用:

- 通过 `Object.getPrototypeOf(obj)` 间接访问指定对象的 `prototype` 对象
- 通过 `Object.setPrototypeOf(obj, anotherObj)` 间接设置指定对象的 `prototype` 对象
- 部分浏览器提前开了 `__proto__` 的口子，使得可以通过 `obj.__proto__` 直接访问原型，通过 `obj.__proto__ = anotherObj` 直接设置原型
- ECMAScript 2015 规范只好向事实低头，将 `__proto__` 属性纳入了规范的一部分

从浏览器的打印结果我们可以看出，上图对象 `a` 存在一个`__proto__`属性。而事实上，他只是开发者工具方便开发者查看原型的故意渲染出来的一个虚拟节点。虽然我们可以查看，但实则并不存在该对象上。

`__proto__`属性既不能被 `for in` 遍历出来，也不能被 `Object.keys(obj)` 查找出来。

访问对象的 `obj.__proto__` 属性，默认走的是 `Object.prototype` 对象上 `__proto__` 属性的 get/set 方法。

`__proto__`是对象所独有的，并且`__proto__`是**一个对象指向另一个对象**，也就是他的原型对象。我们也可以理解为父类对象。它的作用就是当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就回去它的`__proto__`属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就回去其父类的`__proto__`属性所指向的父类的父类上去查找。以此类推，知道找到 `null`。而这个查找的过程，也就构成了我们常说的**原型链**。



### prototype

> object that provides shared properties for other objects

在规范里，`prototype` 被定义为：给其它对象提供共享属性的对象。`prototype` 自己也是对象，只是被用以承担某个职能罢了。

所有对象，都可以作为另一个对象的 `prototype` 来用。



**`prototype`是函数所独有的**。**它的作用就是包含可以给特定类型的所有实例提供共享的属性和方法。它的含义就是函数的远行对象，**也就是这个函数所创建的实例的远行对象，正如上图：`nealyang.__proto__ === Person.prototype`。任何函数在创建的时候，都会默认给该函数添加 `prototype` 属性.



### constructor

**constructor属性也是对象所独有的**，它是**一个对象指向一个函数，这个函数就是该对象的构造函数**。

注意，每一个对象都有其对应的构造函数，本身或者继承而来。单从`constructor`这个属性来讲，只有`prototype`对象才有。每个函数在创建的时候，JavaScript 会同时创建一个该函数对应的`prototype`对象，而`函数创建的对象.__proto__ === 该函数.prototype`，该`函数.prototype.constructor===该函数本身`，故通过函数创建的对象即使自己没有`constructor`属性，它也能通过`__proto__`找到对应的`constructor`，所以任何对象最终都可以找到其对应的构造函数。

唯一特殊的可能就是我开篇抛出来的一个问题。JavaScript 原型的老祖宗：`Function`。它是它自己的构造函数。所以`Function.prototype === Function.__proto`。



首先我们需要明确两点：`__proto__`和 `constructor` 是**对象**独有的。`prototype`属性是**函数**独有的；

但是在 JavaScript 中，函数也是对象，所以函数也拥有 `__proto__` 和 `constructor` 属性。	



`__proto__` 是什么？

实例.`__proto__` = 构造函数的.prototype

也就是说`__proto__` 指向的是构造函数的 prototype

`__proto__` 就是让你这个实例访问构造函数的prototype





constructor 构造函数（构造器）



如果将 constructor 函数的 prototype 改名为 properties。问题可能少很多。或者进一步简写成props，理解上将更加简单。不就是 new Constructor时，自带了它的 Constructor.props 对象嘛