# 构造函数、原型、实例、类



### 前言

构造函数、原型、实例、类是分别是什么？怎么解释



### 构造函数

一种用于创建或者初始化 class 对象的特殊方法；

生成对象 基于构造函数和原型



var obj  = {}

1、**constructor 函数模板** 创建对象

2、constructor 属性 告诉 实例 你的爸爸是谁 谁创造了你





对象、函数、原型、继承、构造函数、实例、类







高程4中对构造函数、原型和实例的关系的描述：

> 每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针（`__proto__`）指向原型。

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.sayName = function() {
    console.log('hello', this.name)
}

const johan = new Person('johan', 22)

```

这个案例中，Person 是构造函数，它有一个属性 prototype，这个属性负责构造函数共享的数据、方法。而这个原型对象有一个属性叫 constructor，指回构造函数 Person。由 Person 构建出的实例 johan，有一个内部指针（`__proto__`）指向创建它的原型

```javascript
Person.prototype.constructor === Person
johan.__proto__ === Person.prototype
```

这里不仅有一个思考？如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数，这样就在实例和原型之间构建了一条原型链

![image-20210415144321299](https://i.loli.net/2021/04/15/nfZbSWMTjVzr2lv.png)

本质是链表，每个构造函数中的原型是一个节点，通过节点来进行继承

而“实例”一词，给人的感觉是和类相关



用原型链怎么个继承法：

```javascript
function Person() {}

function Man() {}

Man.prototype = new Person()

const johan = new Man()

console.log(johan)
```

![image-20210415152547277](https://i.loli.net/2021/04/15/YIUl3MLayuTpNRk.png)

关系伪代码：

```javascript
johan.__proto__ === Man.prototype
Man.prototype.__proto__ === Person.prototype
Person.prototype.__proto__ === Object.prototype
```



```javascript
function Person() {
    this.colors = ['red', 'green', 'blue']
}

function Man() {}

Man.prototype = new Person()

const johan = new Man()

johan.colors.push('yellow')

console.log(johan.colors)

const elaine = new Man()
console.log(elaine.colors)
```

在 Person 中定义的属性，因为继承的缘故（Man.prototype = new Person()），使得 Person的属性变成了公共属性

new Person() 就是创建一个实例

Man.prototype = new Person()

Man这个构造函数的原型等于Person创建的一个实例

这个实例的`__proto__` 等于 Person.prototype

所以可以翻译为：

```javascript
Man.prototype = new Person() // 可以翻译为
Man.prototype.__proto__ === Person.prototype
```





还记得之前的例子吗？

```javascript
Person.prototype.__proto__ === Object.prototype
```



我觉得以后看到 new 的第一反应是：

`实例.__proto__ === 构造函数.prototype`



### 类

#### 什么是类？







回到上述问题

类和实例是匹配的，金丝雀是鸟类的一种。对个人对集体的关系

而原型是链表关系，就好比古董收藏，我是蒙娜丽莎的拥有者，它的上一任是XX，它的上上任是XXX，在 JavaScript 语言中，你能动态改变上一任或者上上任。只要把prototype对象中的constructor指向更改即可

类继承，是集合继承

原型继承，是树状继承



本质是链表，每一个构造函数是一个节点，而不是几个集合













#### 原型式继承

```javascript
function object(o) {
    function F() {}
    F.prototype = o;
    return new F()
}
let person = { 
 	name: "Nicholas", 
 	friends: ["Shelby", "Court", "Van"] 
}; 
var a = object(person)

a.__proto__ === F.prototype === person
a.__proto__ === person
```









首先是对象，

```javascript
function myNew(Con, ...rest) {
    var obj = Object.create(Con.prototype)
    var result = Con.apply(obj, rest);
    if (typeof result === 'object') {
        return result
    } else {
        return obj
    }
}
```









社区上一直有人说：类的概念，但是 JavaScript 是这样吗？

JavaScript 的”类模式“的本质是 基于原型而做的

原型继承是怎么样的



类继承有什么问题

思想上的改变

基于原型的继承是指针的继承，好比你有一块宝石，传给了一个人，然后这个人把宝石镶嵌到手套里，再传给了另一个人，



而基于类的联想，人们会想当然的这么想：

动物是动物类，狗也是一种类，哈士奇是狗类的一个实例，

问题来了，你怎么看

```javascript
dog.prototype = new Animal()
// 按照类的思考模式：实例的原型继承自动物
class Dog extends Animal {
    
}
```





本质是链表，每一个构造函数是一个节点，而不是几个集合





```javascript
function YeFamily() {}
YeFamily.prototype.xinfa = function() {
    console.log('上天下地无敌心法')
}
function OldMan() {}
OldMan.prototype = new YeFamily()
OldMan.prototype.has = function() {
    console.log('上古盔甲')
}
function DayMan() {}
DayMan.prototype = new OldMan()
DayMan.prototype.say = function() {
    console.log('爱吹牛逼')
}
```



所谓的继承，就是`__proto__` 指针指向对象的问题



这个例子也不太好

因为指针有任意性的特点

少年可以继承自父亲（组长），也可以继承自老族长或者老祖宗，只不过继承（`__proto__`指向问题）

这里牵扯到 new 问题，new 操作符会在内部创建一个对象，继承自构造函数





```javascript
class A {}
class B extends A {}

const b = new B();
```



答案：

```javascript
b.__proto__ === B.prototype 
B.prototype.__proto__ === A.prototype
```





原型是什么？原型对象又是什么？



`Function.__proto__ === Function.prototype`





### 面试题

颜海镜原型面试题









## 参考资料

- [JavaScript面向对象编程（二）：构造函数的继承](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html)

- [从原型聊到原型继承，深入理解JavaScript面向对象精髓](https://juejin.cn/post/6844903856376119304)

- [为什么原型继承很重要](https://segmentfault.com/a/1190000002596600)