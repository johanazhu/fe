# 拷贝的秘密

上上一节讲到：基本类型的复制，只要赋值就能克隆到样本，但是引用对象不能，等于号“=” 只是把对象的地址赋值给另一个对象。

```javascript
var obj1 = {};
var obj2 = obj1; // 将obj1的引用地址赋值给obj2
obj1.name = 'johan';
console.log(obj1); // { name: 'johan' }
console.log(obj2); // { name: 'joahn' }
console.log(obj1 === obj2); // true,指向的是同一个地址
```

那么怎么拷贝引用类型呢？这里就有两种分类，依据是是否完全拷贝。

-   浅拷贝是创建一个新对象，这个对象对原始对象属性值进行复制

    -   属性是基础类型，拷贝的就是基本类型的值，修改内容不影响
    -   属性是引用类型，拷贝的就是内存地址，修改内容互相影响

-   深拷贝：整个对象拷贝到另一个内存中，修改内容互不影响

首先我们要看看最简单的浅拷贝是怎么样，让我们对其有个初步的认识，然后在总结下对象中到底有多少种浅拷贝方法

```javascript
var obj1 = {};
var obj2 = Object.assign(obj1);
obj1.name = 'elaine';
console.log(obj2); // { name: elaine }
```

拷贝原对象的引用，就是最简单的浅拷贝

|        | 与原数据是否指向同一对象 | 原数据为基本类型             | 原数据为引用类型             |
| ------ | ------------------------ | ---------------------------- | ---------------------------- |
| 赋值   | 是                       | 改变【会】使原数据一同改变   | 改变【会】使原数据一同改变   |
| 浅拷贝 | 否                       | 改变【不会】使原数据一同改变 | 改变【会】使原数据一同改变   |
| 深拷贝 | 否                       | 改变【不会】使原数据一同改变 | 改变【不会】使原数据一同改变 |

那让我们来看看有多少种浅拷贝，再来试着写一个

## 浅拷贝

### Object 中的 Object.assign

Object.assign()方法可以把任意多个原对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。

它拷贝的是对象的属性的引用，而不是对象本身。

是 ES6 中 Object 对象新增的方法

参数：

target：目标对象

sources: 任意多个原对象。

返回值：目标对象会被返回

案例一

```javascript
var obj1 = { a: 10, b: 20, c: 30 };
var obj2 = Object.assign({}, obj1);
obj2.b = 100;
console.log(obj1); // {a: 10, b: 20, c: 30}
console.log(obj2); // {a: 10, b: 100, c: 30}
```

案例二

```javascript
var obj = { a: { a: 'hello', b: 21 } };
var initialObj = Object.assign({}, obj);

initialObj.a.a = 'changed';
console.log(obj.a.a); // "change"
```

可以看出，Object 只能拷贝第一层对象，如果再往深一层拷贝，就有问题了

### Object/Array 都适用的扩展运算符（...）

扩展运算符，可以在函数调用/数组构造时，将数组表达式或者 string 在语法层面展开；还可以在构造字面量对象时，将对象表达式按 key-value 的方式展开

城然，我们都知道展开运算符的作用并不是为了拷贝。但无可厚非，拷贝也是展开运算符的特点之一

一维数组

```javascript
var arr = [1, 2, 3];
var arr2 = [...arr];
arr2.push(4);

// arr2 [1, 2, 3, 4]
// arr1 不受影响
```

多维数组

```javascript
var a = [
    [1, 2],
    [3, 4],
    [5, 6],
];
var b = [...a];
b.shift().shift();
// b [[3, 4], [5, 6]]
// a [[2], [3, 4], [5, 6]]
```

扩展运算符也是 浅拷贝

### Array 中的 slice

**slice()** 方法返回一个新的数组对象，这一对象是一个由 `begin` 和 `end` 决定的原数组的浅拷贝（包括 `begin`

，不包括 `end` ）。原始数组不会被改变

```javascript
const leiFamily = [
    'father',
    'mother',
    'brother',
    ['sister0', 'sister1', 'sister2'],
];
const copyFamily = leiFamily.slice();
copyFamily[0] = 'Deku';
copyFamily[3][1] = 'brother1';
console.log(leiFamily); // ['father', 'mother', 'brother', ['sister0' , 'brother1', 'sister2']]
console.log(copyFamily); // ['Deku', 'mother', 'brother', ['sister0' , 'brother1', 'sister2']]
// 复制一层，第二层开始引用
```

### Array 中的 concat

concat() 方法用于合并两个或多个数组。此方法不会改变现有数组，而是返回一个新数组

```javascript
const array1 = ['a', 'b', ['c0', 'c1', 'c2']];
const array2 = array1.concat();
array2[1] = 'B';
array2[2][1] = 'C1';
console.log(array1); // ['a', 'b', ['c0', 'C1', 'c2']]
console.log(array2); // ['a', 'B', ['c0', 'C1', 'c2']]
// 复制一层，第二层开始引用
```

slice 和 concat 这两个方法，仅适用于对不包含引用对象的一维数组的深拷贝

## 自己实现一个浅复制

```javascript
function shallowClone(source) {
    if (typeof target === 'object' && target !== null) {
        var target = Array.isArry(source) ? [] : {};
        for (let prop in source) {
            if (source.hasOwnProperty(prop)) {
                target[prop] = source[prop];
            }
        }
        return target;
    } else {
        return source;
    }
}
```

> PS: hasOwnProperty，表示此对象上自己拥有的属性。想起会在后面讲[对象](./对象.md)属性时介绍

简单来说，浅拷贝只复制一层对象的属性。

综上分析，JavaScript 的浅拷贝有 4 种，针对数组的浅拷贝有 slice、concat、扩展运算符， Object.assign() 是针对对象所作的浅拷贝，当然，扩展运算符也适用对象

## 深拷贝

我们已经知道了浅复制的概念和展示浅复制所有的方法。那么深拷贝是什么？有多少方式实现深拷贝呢？

简单来说，深拷贝就是递归复制了所有层级的对象的属性

一般用 JSON.parse(JSON.stringify()) 来解决，这个方法比较简单，大家有常用。但是这个方法也有几个坑

> 1. 它无法实现对函数、RegExp 等特殊对象的克隆
> 2. 它会抛弃对象的 constructor，所有的构造函数会指向 Object
> 3. 对象有循环引用，会报错

我们来测试一下这几个坑，

```javascript
// 构造函数
function Person(name) {
    this.name = name;
}

const Elaine = new Person('elaine');

// 函数
function say() {
    console.log('hi');
}

const oldObj = {
    a: say,
    b: new Array(1),
    c: new RegExp('ab+c', 'i'),
    d: Elaine,
};

const newObj = JSON.parse(JSON.stringify(oldObj));

// 无法复制函数
console.log(newObj.a, oldObj.a); // undefined [Function: say]
// 稀疏数组复制错误
console.log(newObj.b[0], oldObj.b[0]); // null undefined
// 无法复制正则对象
console.log(newObj.c, oldObj.c); // {} /ab+c/i
// 构造函数指向错误
console.log(newObj.d.constructor, oldObj.d.constructor); // [Function: Object] [Function: person]
```

我们可以看到在对函数、正则对象。稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。

```javascript
const oldObj = {};
oldObj.a = oldObj;

const newObj = JSON.parse(JSON.stringify(oldObj));
console.log(newObj.a, oldObj.a); // TypeError: Converting circular structure to JSON
```

对象的循环引用回抛出错误

### 让我们手写一个

我们知道深拷贝就是递归+浅拷贝

所以我们自然而然的想到，如果是需拷贝对象中有对象，就对它进行再一次的拷贝，知道所有的对象中没有对象。很绕是吧，看代码能一目了然

```javascript
function deepClone(source) {
    var target = {};
    for (let prop in source) {
        if (source.hasOwnProperty(prop) && target[prop] === 'object') {
            target[prop] = deepClone(source[prop]);
        } else {
            target[prop] = source[prop];
        }
    }
    return target;
}
```

```javascript
function deepClone(obj) {
    // 如果是 值类型 或 null，则直接return
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }

    // 定义结果对象
    let copy = {};

    // 如果对象是数组，则定义结果数组
    if (obj.constructor === Array) {
        copy = [];
    }

    // 遍历对象的key
    for (let key in obj) {
        // 如果key是对象的自有属性
        if (obj.hasOwnProperty(key)) {
            // 递归调用深拷贝方法
            copy[key] = deepClone(obj[key]);
        } else {
            copy[prop] = obj[prop];
        }
    }

    return copy;
}
// 修言版本
```

但这远远不够，我们做的工具需要适配大多数情况，有几种情况视为必须考虑范围，例如：

-   没有对传参进行校验，传入 `null` 时应该返回 `null` 而不是 `{}`

-   对于对象的判断逻辑不严谨，因为 `typeof null === 'object'`

-   没有考虑数组，正则，Date 的兼容

就像之前谈到过的判断类型是个很重要的环节，我们要知道 null 对应的是 null，object 对应的是 object，string 对应的是 string，数组对应是 array，函数 对应的是 funtion

```javascript
function isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
}
function isArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
}
function isFunction(obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
}
function isDate(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
}
function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
}
```

具体查看细节 [判断所有类型的工具 isType](./JavaScript由什么组成)

提示：注意 toString 方法在 Date(),Array 等多个构造函数上重置过，所以最靠谱的还是从 Object 上的 toString 做分析

```javascript
function deepClone(source) {
    if (source === null) return null;
    if (typeof source !== 'object') return source; // 非对象返回自身

    // var target = Array.isArray(source) ? [] : {};
    var target = {};
    if (isType(source) === 'regexp') {
        // 对正则进行深拷贝
        target = new RegExp(source);
    } else if (isType(source) === 'date') {
        // 对Date对象进行深拷贝
        target = new Date(source.getTime());
    } else if (isType(source) === 'array') {
        // 处理 Array 对象
        target = [];
    } else {
        // 处理 Object 对象
        // target = new obj.constructor();
    }
    for (let prop in source) {
        if (source.hasOwnProperty(prop)) {
            target[prop] = deepClone(source[prop]);
        } else {
            target[prop] = source[prop];
        }
    }
    return target;
}
```

### hash table 破解循环引用

我们需要有一个表来记录当前对象和拷贝对象的对应关系，当我们需要拷贝当前对象时，先去存储空间（表）中找，有没有拷贝过这个对象，如果有的话，直接返回，如果没有的话继续拷贝。

这个存储空间，需要可以存储 `key-value` 形式的数据，且 `key` 可以使一个引用类型，我们使用 `Map` 数据结构

-   检查 `map` 中有无克隆过对象
-   有 - 直接返回
-   没有 - 将当前对象作为 `key`，克隆对象作为 `value` 进行存储
-   继续拷贝

```javascript
function deepClone(source, map = new Map()) {
    if (!isObject(source)) return source; // 非对象返回自身

    var target = Array.isArray(source) ? [] : {};
    if (map.get(source)) {
        return map.get(source);
    }
    map.set(source, target);
    for (let prop in source) {
        if (source.hasOwnProperty(prop)) {
            target[prop] = deepClone(source[prop]);
        } else {
            target[prop] = source[prop];
        }
    }
    return target;
}
```

但递归浅拷贝也有一个缺点，它对庞大的数据来说性能不好，因为需要把整个对象都遍历一遍。

那么有没有一种方法，只有当属性修改以后才对这部分数据做深拷贝，又能解决 JSON.parse(JSON.stringify(a))的局限，答案是 Proxy，具体细节请看[这篇文章](https://juejin.cn/post/6844904021627502599)，本人暂时对 Proxy 不太熟悉

### 他人的深拷贝

```javascript
function deepCopy(origin) {
    const type = getType(origin);
    let copy;
    switch (type) {
        case 'array':
            return copyArray(origin, type, copy);
        case 'object':
            return copyObject(origin, type, copy);
        case 'function':
            return copyFunction(origin, type, copy);
        default:
            return origin;
    }
}

function copyArray(origin, type, copy = []) {
    for (const [index, vale] of origin.entries()) {
        copy[index] = deepCopy(value);
    }
    return copy;
}

function copyObject(origin, type, copy = {}) {
    for (const [key, value] of Object.entries(origin)) {
        copy[key] = deepCopy(value);
    }
    return copy;
}

function copyFunction(origin, type, copy = () => {}) {
    const fun = eval(origin.toString());
    fun.prototype = origin.prototype;
    return fun;
}
```

## 总结

深拷贝是前端面试中必考的一项，它问你怎么手写，你若是只写了 JSON.parse(JSON.stringify(source))肯定是不合格的。这个问题可以衍生出很多问题，例如数据类型的判断，for 循环，原型链，递归以及 hash 表（key-value 形式存储数据）等等

## 参考资料

-   [使用 slice 和 concat 对数组的深拷贝和浅拷贝](https://www.cnblogs.com/baiyangyuanzi/p/6518218.html)
-   [头条面试官：你知道如何实现高性能版本的深拷贝嘛？](https://juejin.cn/post/6844904021627502599)
-   [如何写出一个惊艳面试官的深拷贝](www.conardli.top/blog/article/JS进阶/如何写出一个惊艳面试官的深拷贝.html)
