# 0.1+0.2为什么不等于0.3







**第一部分**



早些年在学js的时候这个问题确实碰到过，最后也只是取整而已，知道有这么回事从来不去思考为什么，因为毕竟是非科班出身。但是最近在学c++的时候，和这个问题杠上了，倒不是因为会阻塞学习流程，主要还是想弄懂；



回答这个问题之前首先我们等学习下计算机存储的模式；很简单不要怕；



计算机在硬件上存储数据的时候，大家都知道是二进制1010101010，这样；



比如说每个字节是8位，int类型占4个字节，也就是32位精度；那么32位的计算机精度可以存2的32次方个数据；如下图：

![image](https://s2.loli.net/2022/01/05/ImJCa2rFz6jN5vg.png)



每个位上面可以放两个二进制数值也就是 0 或者 1；一般最高位上是符号位(1表示负数，0表示正数)，所以带符号类型数据应该是31个2



2 * 2 * 2 *...... * 2(31个2)   ，加上符号范围就是-2147483648 ~ 2147483647；当然也有无符号整型，暂不讨论；



好理解吧；



继续，那么小数怎么存呢，小数在计算机当中叫浮点型，JS最终会由浏览器引擎转成C++，但是js当中只有一种数值类型，那就是 **number**，那么number在c++是什么类型呢；



我们暂且认为它是双精度类型，也就是double，c++中占四个字节，也就是 64 位存储；整数存储参考上面就行；重点说说浮点存储；

同样64位可以分为三部分；



什么是 IEEE 754？



第一部分：符号位(S)，占1位即第63位；

第二部分：指数域(E)，占11位即第52位到62位，含52和62；

第三部分：尾数域(F)，占52位即第0位到51位，含51；



![img](https://i.loli.net/2021/07/28/bFDXJ3NcyMk6lgm.png)



现在我要把一个小数变成二进制64位怎么表示呢？比如说   12.52571；

先转换成二进制（十进制如何转换二进制）是

1100.100001101001010011101110001110010010111000011111 =>

1.100100001101001010011101110001110010010111000011111 * 2^3 （小数点向左偏移了三位）（为什么要偏移呢？）



**得出结论(**IEEE 754标准**)**

1、因为是正数，所以符号位S是0；

2、因为向左偏移了三位，所以E = 1023 + 3 = 1026 (转化为二进制)=> 10000000010 ，有11位，不够前面补0；（为什么要加1023呢？为什么左移是加3，不是减3？）

3、尾数是（F）（小数点后面）100100001101001010011101110001110010010111000011111；



最终表示： 0 10000000010 100100001101001010011101110001110010010111000011111；

上面总长度是63位，差一位，最后面补零，即

**0 10000000010 1001000011010010100111011100011100100101110000111110；**

那么12.52571的64位计算机存储形式就是上面了；



**第二部分**



上面肯定有些问题，大家会迷惑，暂且不表；那么0.1和0.2大家就知道怎么转了；

但是这里有个问题，0.1和0.2转成二进制小数点后面是循环的；



```javascript
 // 0.1 转化为二进制
0.0 0011 0011 0011 0011...(0011无限循环）
// 0.2 转化为二进制
0.0011 0011 0011 0011 0011...(0011无限循环）
```



由于尾数只有52位（52位之后的被计算机截掉了）

```
E = -4; F =1001100110011001100110011001100110011001100110011010 (52位)
E = -3; F =1.1001100110011001100110011001100110011001100110011010 (52位)
```



要让两个数相加，首先E需要相同，于是得出下面

```
E = -3; F =0.1100110011001100110011001100110011001100110011001101 (52位) //多余位截掉
E = -3; F =1.1001100110011001100110011001100110011001100110011010 (52位)
```



上面两个相加得出

```
E = -3; F = 10.0110011001100110011001100110011001100110011001100111
-------------------------------------------------------------------
E = -2; F = 1.00110011001100110011001100110011001100110011001100111
```



把第六行转成10进制之后就是：0.30000000000000004；



剩余

比如在转的时候还要考虑E的取值情况



## 参考资料

- [揭秘 0.1 + 0.2 != 0.3](https://www.barretlee.com/blog/2016/09/28/ieee754-operation-in-js/)

- [浮点数0.1+0.2为何不等于0.3](https://mp.weixin.qq.com/s?__biz=MzIzOTkwMjM0OQ==&mid=2247484123&idx=1&sn=dea6a74f6010c32e1dd79a50d2c00206&chksm=e9224939de55c02fb8ad467c5a728ba72deca543135146766762d319f06d8a2380a01f67808d&mpshare=1&scene=1&srcid=&sharer_sharetime=1567574623469&sharer_shareid=778ad5bf3b27e0078eb105d7277263f6#rd)

  
