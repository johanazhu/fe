# 防抖（debounce）

在前端代码中，我们常会遇到一些场景，滚动屏幕，上拉加载图片，搜索关键字，如果前端不做处理，把请求都交给后端，后端的压力就会非常大，这样导致用户体验也会受到一些影响，所以在日常开发中，我们会对其进行防抖和节流的操作。

本节我们来讲讲防抖

## 原理

防抖的原理是：不管事件触发频率有多高，一定在事件触发 `n` 秒后才执行。如果你在事件触发的 `n` 秒内又触发了这个事件，那就以新事件的时间为准，`n` 秒后才执行。总之，要等你触发完事件 `n` 秒内不再触发事件，我才执行

根据这段表述，我们可以写第一版的代码：

```javascript
function debounce(func, wait) {
    var timeout;
    return function () {
        clearTimeout(timeout);
        timeout = setTimeout(func, wait);
    };
}
```

## this

如果我们在 `getUserAction` 函数中`console.log(this)` , 在不使用 `debounce` 函数的时候， `this` 的值为：

```htnl
<div id="container"></div>
```

但是如果使用我们的 debounce 函数，this 就会指向 Window 对象

所以我们要改变 this 的指向，让它指向它该指向的地方

```javascript
// 第二版
function debounce(func, wait) {
    var timeout;

    return function () {
        var self = this;

        clearTimeout(timeout);
        setTimeout(function () {
            func.apply(self); // 使用 func.bind(self) 一样的效果
        }, wait);
    };
}
```

现在 this 已经可以正确指向了。让我们看下个问题

## event 问题

JavaScript 在事件处理函数中会提供事件对象 event，我们修改下 getUserAction 函数：

```javascript
function getUserAction(e) {
    console.log(e);
    container.innerHTML = count++;
}
```

如果我们不适用 debounce 函数，这里会打印 MouseEvent 对象

![dobounce](https://s2.loli.net/2022/03/10/wer6RLOfZ3pUgxu.png)

但是在我们实现的 debounce 函数中，却只会打印 undefined！

所以我们需要修改一下代码，将参数赋值上去

```javascript
// 第三版
function debounce(func, wait) {
    var timeout;

    return function () {
        var self = this;
        var args = arguments;

        clearTimeout(timeout);
        timeout = setTimeout(function () {
            func.apply(self, args);
        }, wait);
    };
}
```

到此为止，我们修复了两个小问题：

-   this 指向
-   event 对象

其实到这里，就已经实现了防抖的“面试”代码，但我们的可以再次基础上再完善一番

## 立即执行

需求：我不希望非要等到事件停止出发后才执行，我希望立即执行函数，然后等到停止触发 n 秒后，才可以重新触发执行

那么我们加个 immediate 参数判断是否是立刻执行

```javascript
// 第四版
function debounce(func, wait, immediate) {
    var timeout;

    return function () {
        var self = this;
        var args = arguments;

        if (timeout) clearTimeout(timeout);
        if (immediate) {
            // 如果已经执行过，不再执行
            var callNow = !timeout;
            timeout = setTimeout(function () {
                timeout = null;
            }, wait);
        } else {
            setTimeout(function () {
                func.apply(self, args);
            }, wait);
        }
    };
}
```

## 返回值

此时注意一点，getUserAction 函数可能是有返回值的，所以我们也要返回函数的执行结果，但是当 immediate 为 false 的时候，因为使用了 setTimeout，我们将 func.apply(self, args) 的返回值赋值给变量，最后再 return 的时候，值将会一直是 undefined，所以我们需要在 immediate 为 true 的时候返回函数的执行结果

```javascript
// 第五版
function debounce(func, wait, immediate) {
    var timeout, result;

    return function () {
        var self = this;
        var args = arguments;

        if (timeout) setTimeout(timeout);

        if (immeduate) {
            var callNow = !timeout;
            timeout = setTimeout(function () {
                timeout = null;
            }, wait);
            if (callNow) result = func.apply(self, args);
        } else {
            timeout = setTimeout(function () {
                func.apply(self, args);
            }, wait);
        }
        return result;
    };
}
```

## 有返回值但不立即执行

如果我们没有 immediate 参数，但需要返回值怎么办？

```javascript
function debounce(func, wait) {
    var timeout, result;

    return function () {
        var self = this;
        var args = arguments;

        if (timeout) clearTimeout(timeout);
        timeout = setTimeout(function () {
            func.apply(self, args);
        }, wait);
    };
}
```

## 取消

最后我们希望能取消 debounce 函数，比如说 debounce 的时间间隔是 10 秒钟，immediate 为 true，这样的话，我只有等 10 秒后才能重新出发事件，现在我希望有个按钮，点击后，取消防抖，这样我们再去触发，就可以又立即执行了

```javascript
// 第六版
function debounce(func, wait, immediate) {
    var timeout, result;

    var debounced = function () {
        var self = this;
        var args = arguments;

        if (timeout) setTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;

            timeout = setTimeout(function () {
                timeout = null;
            }, wait);
            if (callNow) result = func.apply(self, args);
        } else {
            timeout = setTimeout(function () {
                func.apply(self, args);
            }, wait);
        }
        return result;
    };

    debounced.cancel = function () {
        clearTimeout(timeout);
        timeout = null;
    };
    return debounced;
}
```

如何使用这个 cancel 函数呢？依然是以上面的 demo 为例

```javascript
var count = 1;
var container = document.getElementById('container');

function getUserAction(e) {
    container.innerHTML = count++;
}

var setUseAction = debounce(getUserAction, 10000, true);

container.onmousemove = setUseAction;

document.getElementById('button').addEventListener('click', function () {
    setUseAction.cancel();
});
```

至此我们已经完整实现了一个 underscore 中的 debounce 函数

最新的 1.10.2 的 debounce 源码

```javascript

```

## ES6 版本

```javascript
function debounce(func, time, flag) {
    let timer = null;
    function debounced(...args) {
        clearTimeout(timer);
        if (flag && !timer) {
            func.apply(this, args);
        }
        timer = setTimeout(() => {
            func.apply(this, args);
        }, time);
    }
    debounced.cancel = function () {
        clearTimeout(timer);
        timer = null;
    };
    return debounced;
}
```

## 附录

做动画时常用的防抖：一帧时间中（16ms）渲染多次（骗过肉眼即可）

```javascript
function debounce(func) {
    var t;
    return function () {
        cancelAnimationFrame(t);
        t = requestAnimationFrame(func);
    };
}
```

代码已经部署在 codepen.io 上，可以通过 [这里](https://codepen.io/jojobo/pen/KKNYoQx) 查看

无论是防抖，还是节流，都是闭包的引用

防抖和节流都是防止某一时间频繁触发，但是原理不一样

防抖是某一段时间内只执行一次，而节流是间隔时间执行

引用场景：

debounce

-   search 搜索联想，用户在不断输入值时，用防抖来节约请求资源。
-   window 触发 resize 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次

throttle

-   鼠标不断点击触发，mousedown（单位时间内只触发一次）
-   监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断

### 如何区分节流和防抖

防抖是虽然事件持续触发，但只有等事件停止触发后 n 秒才执行函数，节流是持续触发的时候，每 n 秒执行一次函数

## 参考资料

-   [underscore 的 debounce 源码](https://github.com/jashkenas/underscore/blob/master/modules/debounce.js)
-   [JavaScript 专题之跟着 underscore 学防抖](https://github.com/mqyqingfeng/Blog/issues/22)
-   [codepen 在线代码平台](https://codepen.io/jojobo/pen/KKNYoQx)
-   [Debouncing and Throttling Explained Through Examples](https://css-tricks.com/debouncing-throttling-explained-examples/)
-   [防抖节流场景及应用](https://mp.weixin.qq.com/s/XzqwfdG4-whUaAxxnXITmg)
