# 节流



## 原理

**如果你持续触发事件，每隔一段时间，只执行一次事件**

关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器



## 使用时间戳

当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳（最一开始值设为 0 ），如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行

```javascript
// 时间戳
function throttle(func, wait) {
    var context, args;
    var previous = 0;
    
    return function () {
        var now = +new Date();
        context = this;
        args = arguments;
        if(now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}
```

例子依然是用讲 debounce 中的例子，如果你要使用：

```html
container.onmousemove = throttle(getUserAction, 1000)
```

效果演示如下：

![throttle1](../../.vuepress/public/images/JavaScript/throttle1.gif)

我们可以看到：当鼠标移入的时候，事件立即执行，每过 1s 会执行一次，如果在 4.2s 停止触发，以后不会再执行事件



## 使用定时器

当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器

```javascript
// 定时器
function throttle(func, wait) {
    var timeout, context, args;
    var previous = 0;
    
    return function () {
        context = this;
        args = arguments;
        if (!timeout) {
            timeout = setTimeout(function() {
                timeout = null;
                func.apply(context, args)
            }, wait)
        }
    }
}
```

为了让效果更加明显，我们设置 wait 的事件为 3s，效果演示如下：

![throttle2](../../.vuepress/public/images/JavaScript/throttle2.gif)

我们可以看到：当鼠标移入的时候，事件不会立即执行，晃了 3s 后才执行一次，此后每 3s 执行一次；当数字显示为 3 的时候，立即移出鼠标，相当于大约 9.2s 的时候停止触发，但是依然会在第 12s 的时候执行一次事件

所以比较两个方法：

1.第一种事件会立即执行，第二种事件会在 n 秒后第一次执行

2.第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件



## 两者结合

我们既想要鼠标移入就执行，又想要停止触发后再执行一次

结合两者的优势，我们再写一版

```javascript
function throttle(func, wait) {
    var timeout, context, args;
    var previous = 0;
    
    var later = function () {
        previous = +new Date()
        timeout = null;
        func.apply(context, args)
    }
    
    var throttled = function () {
        var now = +new Date();
        // 下次触发 func 剩余的时间
        var remaining = wait - (now - previous);
        context = this;
        args = argument;
        // 如果没有剩余的时间或者改了系统时间
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout)
                timeout = null
            }
            previous = now;
            func.apply(context, args)
        } else if (!timeout) {
            timeout = setTimeout(later, remaining)
        }
    }
    return throttled
}
```

效果演示如下：

![throttle3](../../.vuepress/public/images/JavaScript/throttle3.gif)

我们可以看到：鼠标移入，事件立即执行，晃了 3s，事件再一次执行，当数字变成 3 的时候，也就是 6s 后，我们立即移出鼠标，停止触发事件， 9s 的时候，依然会再执行一次事件



## 优化

但是我们希望能控制有时候有头无尾，有时候无头有尾，怎么办呢？

我们再设置一个 options 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定：

leading: false 表示禁止第一次执行

trailing: false 表示禁用停止触发的回调

我们再来改一下代码：

```javascript
function throttle(func, wait, options) {
    var timeout, context, args;
    var previous = 0;
    if (!options) options = {}
    
    var later = function() {
        previous = option.leading === false ? 0 : new Date().getTime();
        timeout = null;
        func.apply(context, args)
        if (!timeout) context = args = null;
    }
    
   var throttled = function() {
        var now = new Date().getTime();
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            func.apply(context, args);
            if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
    };
    return throttled;
}
```

## 取消

 在 debounce 的实现中，我们加了一个 cancel 方法，throttle 我们也加个 cancel 方法： 

```javascript
// 非完整代码
...
throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = null;
}
...
```



## 注意

我们要注意 underscore 的实现中有这样一个问题：

那就是 `leading：false` 和 `trailing: false` 不能同时设置。

如果同时设置的话，比如当你将鼠标移出的时候，因为 trailing 设置为 false，停止触发的时候不会设置定时器，所以只要再过了设置的时间，再移入的话，就会立刻执行，就违反了 leading: false，bug 就出来了，所以，这个 throttle 只有三种用法：

```
container.onmousemove = throttle(getUserAction, 1000);
container.onmousemove = throttle(getUserAction, 1000, {
    leading: false
});
container.onmousemove = throttle(getUserAction, 1000, {
    trailing: false
});
```

至此我们已经完整实现了一个 underscore 中的 throttle 函数，恭喜，撒花！



## 原理

防抖（`debounce`）：不管事件触发频率多高，一定在事件触发 `n` 秒后才执行，如果你在一个事件触发的 `n` 秒内又触发了这个事件，就以新的事件的事件为准， `n` 秒后才执行，总之，触发完事件 `n` 秒内不再触发事件， `n` 秒后再执行



[http://www.conardli.top/docs/JavaScript/%E9%98%B2%E6%8A%96.html#%E5%8E%9F%E7%90%86](http://www.conardli.top/docs/JavaScript/防抖.html#原理)



防抖，如果再点击，从头再来

防抖取第近一次的调用





防抖：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效

防抖的理解，可以把它想象成游戏中的CD，技能释放完后要有冷却事件，在这一时间内，你无论怎么按技能，技能不会释放



无论是防抖，还是节流，都是闭包的引用

防抖和节流都是防止某一时间频繁触发，但是原理不一样

防抖是某一段时间内只执行一次，而节流是间隔时间执行



引用场景：

debounce 

- search搜索联想，用户在不断输入值时，用防抖来节约请求资源。
- window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次

throttle 

- 鼠标不断点击触发，mousedown(单位时间内只触发一次)
- 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断



https://github.com/mqyqingfeng/Blog/issues/22







## 参考资料

- [JavaScript专题之跟着 underscore 学节流](https://github.com/mqyqingfeng/Blog/issues/26)