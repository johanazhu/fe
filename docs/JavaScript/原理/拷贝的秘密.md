# 拷贝的秘密



**基本类型**：String、Number、Boolean、Null、Undefined、Symbol

**引用类型**：Object



javascript的内存管理有两种，堆和栈

基本类型放在堆中，

引用类型放在栈中，

基本类型的复制是文件的复制

引用类型的复制是地址的引用



而我们说的深拷贝、浅拷贝是堆js 引用类型的拷贝



### 如何实现深浅拷贝

Q：什么时候用到深浅拷贝？

A：当数据类型威引用类型，需要在不应用源数据时堆数据的操作



浅拷贝：适用于引用类型内值为基本类型

深拷贝：适用于引用类型内值包含引用类型

来观察下面一个场景

```javascript
var foo = {
    name: 'johan',
    age: 22
}
var bar = [1, '2', 3]

var fooCopy = foo;
fooCopy.name = 'elaine';
fooCopy.age = 33

console.log(foo) // {name: 'elaine', age: 33}
console.log(fooCopy) // {name: 'elaine', age: 33}

```



### 浅拷贝

```javascript
// 1.数组拷贝 slice
var barSliceCopy = bar.slice(0)
// 2.数组拷贝 concat
var barConcatCopy = bar.concat()
// 3.对象拷贝 {...}
// 4.对象拷贝 Object.assign()
```







### 术语解释

浅拷贝：只复制一层

深拷贝：无论多少层都能复制



### 浅拷贝：只考虑对象类型

```javascript
function shallowCopy(obj) {
    if (typeof obj !== 'object') return;
    let newObj = obj instanceof Array ? [] : {}
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = obj[key]
        }
    }
    return newObj
}
```

简单版深拷贝：只考虑普通对象，不考虑内置对象和函数

就第一版+递归

```javascript
function deepClone(obj) {
    if (typeof obj !== 'object') return;
    let newObj = obj instanceof Array ? [] : {}
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key]
        }
    }
    return newObj
}
```









### 参考资料

[闲庭信步聊前端 - 一文摸清ES拷贝的深浅](https://zhuanlan.zhihu.com/p/338443023?utm_source=wechat_session&utm_medium=social&utm_oi=56197411504128)

