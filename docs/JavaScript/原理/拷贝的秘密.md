# 拷贝的秘密

**基本类型**：String、Number、Boolean、Null、Undefined、Symbol

**引用类型**：Object

javascript 的内存管理有两种，堆和栈

基本类型放在堆中，

引用类型放在栈中，

基本类型的复制是文件的复制

引用类型的复制是地址的引用

而我们说的深拷贝、浅拷贝是堆 js 引用类型的拷贝

## 如何实现深浅拷贝

Q：什么时候用到深浅拷贝？

A：当数据类型威引用类型，需要在不应用源数据时堆数据的操作

**浅拷贝：适用于引用类型内值为基本类型**

**深拷贝：适用于引用类型内值包含引用类型**

来观察下面一个场景

```javascript
var foo = {
    name: 'johan',
    age: 22,
};
var bar = [1, '2', 3];

var fooCopy = foo;
fooCopy.name = 'elaine';
fooCopy.age = 33;

console.log(foo); // {name: 'elaine', age: 33}
console.log(fooCopy); // {name: 'elaine', age: 33}
```

## 浅拷贝

```javascript
// 1.数组拷贝 slice
var barSliceCopy = bar.slice();
// 2.数组拷贝 concat
var barConcatCopy = bar.concat();
// 3.对象拷贝 {...}
var fooEs6Copy = { ...foo };
// 4.对象拷贝 Object.assign()
var fooAssignCopy = Object.assign({}, foo);
```

## 术语解释

浅拷贝：只复制一层

深拷贝：无论多少层都能复制

## 浅拷贝：只考虑对象类型

```javascript
function shallowCopy(obj) {
    if (typeof obj !== 'object') return;
    let newObj = obj instanceof Array ? [] : {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = obj[key];
        }
    }
    return newObj;
}
```

简单版深拷贝：只考虑普通对象，不考虑内置对象和函数

就第一版+递归

```javascript
function deepClone(obj) {
    if (typeof obj !== 'object') return;
    let newObj = obj instanceof Array ? [] : {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] =
                typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key];
        }
    }
    return newObj;
}
```

JSON.parse(JSON.stringify(foo)) 的缺点：

-   `undefined` 、任意的函数以及 `symbol` 值，在序列化过程中会被忽略（出现在非数组对象的-属性值中时）或者被转移成`null`（出现在数组中时）。函数、`undefined` 被单独转换时，会返回`undefined`，如`JSON.stringify(function(){})` or `JSON.stringify(undefined)`
-   对包含循环引用的对象（对象之间互相引用，形成无限循环）执行此方法，会抛出错误
-   所有以`symbol` 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们

第二版：针对 Symbol 和 循环应用做处理

-   Symbol：每个从 `Symbol()` 返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数组类型建有的目的
-   WeakMap：`WeakMap` 对象时一组键/值对的集合，其中的键时弱引用。其键必须时对象，而值可以是任何值

PS：map 和 WeakMap 的区别在于用 map 声明的对象之间存在强引用关系。即使我们将值进行释放，但是因为存在强应用关系，这部分内存依然无法被释放，而使用 WeakMap 的话，因为键和值是弱引用关系，当下一次垃圾回收机制执行时，这块内存会被释放掉

选择使用 WeakMap 而不是 Map 是由于 WeakMap 持有的是每个键对象的”弱引用“，这意味着在没有其他引用存在时垃圾回收能正常进行

```javascript
const deepClone = (source, storage = new WeakMap()) => {
    // 普通类型直接返回
    if (typeof source !== 'object') return source;
    // 是否是数组
    let newObj = source instanceof Array ? [] : {};
    // 循环引用 - 返回存储的引用数据
    if (storage.has(source)) return storage.get(source);
    // 循环应用 - 设置临时存储值
    storage.set(source, newObj);
    // 是否包含 Symbol 类型
    let isSymbol = Object.getOwnPropertySymbols(source);
    // 若包含 Symbol 类型
    if (isSymbol.length) {
        isSymbol.forEach((item) => {
            if (typeof source[item] === 'object') {
                newObj[item] = deepClone(source[item], storage);
                return;
            }
            newObj[item] = source[item];
        });
    }
    // 不包含 Symbol
    for (let key in source) {
        if (source.hasOwnProperty(key)) {
            newObj[key] =
                typeof source[key] === 'object'
                    ? deepClone(source[key], storage)
                    : source[key];
        }
    }
    return newObj;
};
```

## 参考资料

-   [闲庭信步聊前端 - 一文摸清 ES 拷贝的深浅](https://zhuanlan.zhihu.com/p/338443023?utm_source=wechat_session&utm_medium=social&utm_oi=56197411504128)
