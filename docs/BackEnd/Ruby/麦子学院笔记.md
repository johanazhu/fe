# 麦子学院笔记



## ruby 语言进阶 课程



## 目录

Ruby 介绍

数据结构及常用库模块

- Hash、Set、Range、Symbol、Array、Numbers、Text

Ruby 方法

- Methods and Blocks
- Proc and Lambdas

**Ruby 面向对象编程**

- Class and Module
- Singleton Pettern
- method resolution
- Duck typing and OOP design

**Ruby 常用核心库**

- execption handling
- enumerable and comparable
- Regex
- Date and DateTime
- File Manipulation
- Multithreading in Ruby

Ruby 元编程

- class_eval and instance_eval
- define_method

Ruby 应用

- Web Crawling
- Package Gems



## Ruby 介绍

Ruby 是XXXXX

Ruby 安装

https://rvm.io/rvm/install

https://railsinstaller.org/



## 数据结构及常用库模块

数字

```ruby
3.2 # 3.2
3.2.class # Float 浮点数
3.even? # 是否为偶数
3.odd? # 是否为奇数
283.to_s # 转化为 string 
3.times { p 'love' } # 打印三次 love
3 & 1 # 1 
3.232323.round(2) # 小数点保留 2 位
```



字符串

```ruby
a = 'asdf' # asdf 将 asdf 赋值给a
a[0] = 'b' # ruby 中一切皆对象
a.object_id # 70123455667
a[1] = 'c' # c
a.object_id # 70123455667 ，a 不变
b = 'asdf' # 与 a 的值一样
b.object_id # 72343954534，但 object_id 不一样，说明他们的内存地址不一样，和 JavaScript 的引用类型一样，每次赋值都存在堆内存里，所以说 ruby 性能差
# 在 Ruby 中，一切皆对象，比 JavaScript 更加彻底
a.class # String class 方法是判断它的类型
```

Ruby 的命名

- variable、symbol、method： snake_case
- constant： CONST_FOO
- class name： CamelCase
- file name： file_name.rb

```ruby
a = 'asdf' # 用单引号
"something#{a}" # somethingasdf 双引号相当于 javascript 中的模板字符串(``)
%q('asddas'dasda'') # "'asddas'dasda''"  保留你输入的任何值
%Q("sadsd") # "\"\"sadsd\"\"" 转义 
<<-Text
sdsd
dsadsad
dsdas
TEXT # 多行
"asdfgh".reverse # hgfdsa 反转
"hello".include?('o') # true 是否存在字母o
"hello".index('l') # 2
"asdf".sub('s', 'b') # "adbf" 将 s 替换成 b
"asdf".sub!('s', 'b') # "abdf" 
! 有什么用呢，它能改变原值
a = 'asdf' # asdf
a.sub('s', 'b') # abdf
a # asdf  a 的值没有变化
a.sub!('s', 'b') # abdf
a # abdf  a 的值发生改变
a.size # 字符串长度
```



符号（Symbol）

不可变类型，优点，查找速度快，缺点是不会被垃圾回收，造成内存不够的可能



数组

数组是对象，引用类型

```ruby
a = [] # []
a.object_id # 7012434563
b = a # []
b.object_id # 7012434563 与 a 一样，引用的是同一个内存地址
a << 'foo' # ["foo"]
a # ["foo"]
a.object_id # 7012434563
b # ["foo"]
b.object_id # 7012434563

# 创建方式： 对象字面量[]、还有 Array.new
a = Array.new # []
a = Array.new(3) # [nil, nil, nil] 
a = Array.new(3, 0) # [0,0,0]
```

特别注意

```ruby
a = Array.new(3, 'asdf') # ["asdf", "asdf", "asdf"]
a[0] # "asdf"
a[0][0] = 'b' # b
a[0] # "bsdf"
a # ["bsdf", "bsdf", "bsdf"]
a[0].object_id # 7012838949
a[1].object_id # 7012838949
a[2].object_id # 7012838949
# 因为它们是引用对象，指向同一个引用
# 如何只改变数组中的第一项，不改变其他的，使用 block（块）
a = Array.new(3) { 'asdf' } # ["asdf", "asdf", "asdf"]
a[0].object_id # 7022838393
a[1].object_id # 7323856575
a[2].object_id # 7342657667
```

第三种创建数组的方法

```ruby
arr = %w(foo, bar, baz) # ["foo", "bar", "baz"]
```

数组的常用方法

```ruby
# 以上面 arr 为例子
arr[0] # "foo"
arr[-1] # "baz"
arr[1..2] # 取区间["bar", "baz"]
arr.fetch(0) # foo
arr.fetch(4) # 报错 
arr.fetch(4, "asdf") # "asdf"
arr.length # 3
arr.include?("sdad") # 是否存在sdad ，false
arr.include?('foo') # true
arr.empty?() # 是否为空 false
arr.push('ber') # ["foo", "bar", "baz", "ber"]
arr[7] = 'asdf' # ["foo", "bar", "baz", "ber", nil, nil, nil, "asdf"]
arr.delete("ber") # ["foo", "bar", "baz", nil, nil, nil, "asdf"]
arr.push("bar") # ["foo", "bar", "baz", nil, nil, nil, "asdf", "bar"]
arr.uniq # 取唯一，删除多余的值 ["foo", "bar", "baz", nil, "asdf"]
# arr.uniq! !会改变原数组
arr.shuffle # 颠倒 ["asdf", nil, nil, nil, "baz", "bar", "foo"]
arr1 = [[1,2,3], [4, 5]]
arr.flatten # 扁平化 [1, 2, 3, 4, 5]
```

数组的遍历方法

```ruby
arr = [1, -1, 2, 3, -4]
arr.each { |e| p e } # e 为数组中的每一项， p 为 put 打印， p e 打印每一项值
# 1, -1, 2, 3, -4
arr.reverse_each { |e| p e} # 倒着遍历 -4, 3, 2, -1, 1
arr.each_width_index {|e, i| p [e, i] } # [1, 0] [-1, 1] [2, 2] [3, 3] [-4, 4]
arr.sort # [-4, -1, 1, 2, 3]
arr.select { |e| e > 0} # 选择大于0的元素，[1, 2, 3]
```



哈希

{ } 字面量表示 hash

```ruby
a = { key: 'value' } # {:key => "value"}
b = a # {:key => "value"}
b.object_id # 91860
a.object_id # 91860
a[:key] = 'foo' # foo
a # {:key => "foo"}
b # {:key => "foo"}
```

另一种创建 hash 的方法，new

```ruby
Hash.new # {}
h = Hash.new(3) # {}
h[0] # 3
h[1] # 3
```

哈希的方法

```ruby
h = {a: 1, b: 2}
h[:c] = 3
h # {:a=>1, :b=>2, c=>3}
h[:a] # 1
h.delete(:a) # 1
h # {:b=>2, c=>3}
h.assoc(:b) # 获取 key 和 value [:b, 2]
h.empty?() false 
h.has_value?(2) # 是否有值 2, true
h.has_key?(:b) # 是否有值:b, true
h.keys # [:b, :c]
h.values  # [2, 3]
h.to_a # 变成 array [[:b, 2], [:c, 3]]
h2 = {d: 4}
h.merge(h2) # {:b=>2,:c=>3,:d=>4}
```

hash 的遍历方法

```ruby
h.each { |key, value| p [key, value]} # [:b, 2] [:c, 3]
h.each_key { |key| p key } # :b :c
h.each_value {|v| p v} # 2 3
h.select { |key| key == :b} # {:b=>2}
```



集合（Set）

```ruby
require 'set' # 命令行中默认不引用 set
a = Set.new [1, 2] # <Set: {1, 2}>
a.add("foo") # Set: {1, 2, "foo"}>
b = Set.new [2, 3, 4] #Set: {2, 3, 4}>
a & b # Set: {2}>
a | b # Set: {1, 2, ”foo", "3", "4"}>
a <= b # b 是否是 a 的子集， false
b <= a # a 是否是 b 的子集， false
```



范围（Range）

闭区间

```ruby
r = 1..2 # 1,2 
r.include?(2) # true
a = [1, 2, 3, 4]
a[1..2] # [2, 3]
```



## Ruby 方法



### 方法

语法

```ruby
def foo
    puts "Hello World!"
end
```





### 闭包（block、proc、lambda）

Iterator and block

- block basics
- block variables （closure）
- block flow control

Proc

- proc
- lambda

语法

```ruby
[1,2,3].each do |elem| 
    p elem
end
```



block best practice

```ruby
# 多行 使用 do...end，一行 使用 {...}
arr.each do |elem|
    foo(elem)
    bar(elem)
    baz(elem)
end

arr.each { |e| p e}

# {...} 的优先级大于 do ...end
```







### **Ruby 面向对象编程**

Class and Module

类就是一个包含方法的容器

对象就是一个接收者回答这些方法

```ruby
class Point # CameCase
    def initialize(x, y)
        # @x instance variable 实例变量
        # @@x class variable 类变量
        # $x global variable 全局变量
        # x local variable 本地变量	
        @x, @y = x, y
    end
end
    
# 如何使用
p = Point.new(2, 3) # new 一个类 
```

如何读取类中的变量

```ruby
class Point # CameCase
    attr_accessor :x # getter and setter
    attr_reader :y # getter
    
    def initialize(x, y)
        # @x instance variable 实例变量
        # @@x class variable 类变量
        # $x global variable 全局变量
        # x local variable 本地变量	
        @x, @y = x, y
    end
end
    
# 如何使用
p = Point.new(2, 3) # new 一个类 
p.x # 2
p.x = 3 # 3 
p.y # 3
p.y = 2 # 报错
# p 为 Point 的实例，attr_accessor 说明内部的变量可以都和写，attr_reader 只读
```

类方法，在内部定义时加 self

```ruby
class Point # CameCase
    def initialize(x, y)
        # @x instance variable 实例变量
        # @@x class variable 类变量
        # $x global variable 全局变量
        # x local variable 本地变量	
        @x, @y = x, y
    end
    
    # 第一种
    def self.second_quadrant?(x, y) 
        x < 0 && y > 0
    end
    
    # 第二种
    class << self
        def foo
        end
        def bar
        end
        def baz
        end
    end
end
    
# 如何使用
p = Point.new(2, 3) # new 一个类 
```



















