# 事件循环系统




Event Loop 实际上就是一个 job，用来检测 Call Stack 和 Callback Queue，一旦 Call Stack 里代码执行完以后，就会把 Callback Queue 里第一个 callback 函数放到 Call Stack 里执行



总的来说，JS 是单线程，只有一个 Call Stack，浏览器是多线程的，并且 DOM 事件、AJAX(XMLHttpRequest)、setTimeout 都是有独立的线程处理。在这些异步事件结束，runtime 会把它们的 callback 按顺序放到 Callback Queue 里，Event Loop 会检测 Call Stack，一旦它为空，就会把 Callback Queue 里的回调函数一次放到 Call Stack 里执行，直到 Callback Queue 为空



setTimeout 和 promise 都是异步事件，而且 setTimeout 写在 promise 之前，为什么 setTimeout 的回调要比 promise 后执行呢？那是因为 promise 属于微任务（microtasks）而 setTimeout 属于宏任务（macrotask），微任务的优先级要高于宏任务



在 ES6 规范中，microtasks 称为 jobs，macrotask 称为 task



整个 Event Loop 的执行顺序如下：

- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
- 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取，也就是 callback queue）

流程图如下：

![js-eventloop17](https://i.loli.net/2021/06/11/dWoDPcI4EwCiSa3.png)













微任务和宏任务
面试题


一个线程中，事件循环是唯一的，但是任务队列可以拥有多个

任何队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，他们被分别称为task与jobs

macro-task大概包括：script(整体代码)，setTimeout,setInterval,setImmediate,I/O,UI rendering

micro-task大概包括：procss,nextTick,Promise,Obect.observe(已废弃)，MutationObserver（html5新特性）

setTimeout/Promise等我们称之为任务源

```javascript
// setTimeout中的回调函数才是进入任务队列的任务
setTimeout(function() {
    console.log('xxxx');
})
// setTimeout作为一个任务分发器，这个函数会立即执行，而它所要分发的任务，也就是它的第一个参数，才是延迟执行
```

先执行宏任务（同步代码），然后执行所有的微任务，然后再在下一个宏任务中执行，再执行这个宏任务中的所有微任务

执行过程中，遇到不同的任务分发器，就将任务分发到各自对应的队列中去

如果出现两次setTimeout，都会先进入setTimeout队列

只有当setTimeout中所有的任务执行完毕之后，才会再次开始执行微任务队列

当我们在执行setTimeout任务中遇到setTimeout时，它仍然会将对应的任务分发到setTimeout队列中去，但是该任务就得等到下一轮事件循环执行了。例子中没有涉及到这么复杂的嵌套，大家可以动手添加或者修改他们的位置来感受一下循环的变化。

#### Event loop执行顺序

1.执行同步代码，属于宏任务

2.执行站为空，查询是否有微任务需要执行

3.执行所有的微任务

4.必要的话渲染UI

5.然后开始下一轮 Event loo，执行宏任务中的代步代码

微任务包括：provess.nextTick，promise，Object.observe，MutationObserver

宏任务包括：script，setTimeout，setInterval，setImmediate，I/O，UI rendering



用一道大厂面试题带你搞懂事件循环机制

https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484610&idx=2&sn=72b77572a8c42fe6c165336ce0a035c1&chksm=ea0167aedd76eeb8cfdc05c058bb3967f6dcbb6a20eef43f0afd2398a52d2d8ead2895a35118&mpshare=1&scene=1&srcid=&sharer_sharetime=1567556614880&sharer_shareid=778ad5bf3b27e0078eb105d7277263f6#rd





从多线程到 Event Loop 全面梳理

https://juejin.im/post/5d5b4c2df265da03dd3d73e5#comment





带你彻底搞懂 Event Loop

https://segmentfault.com/a/1190000016278115?utm_source=tag-newest&tdsourcetag=s_pctim_aiomsg





面试题：说说事件循环机制

https://mp.weixin.qq.com/s?__biz=MjM5NTk4MDA1MA==&mid=2458073291&idx=1&sn=11b940e35244bfdd81b8261d1412e0a9&chksm=b187aeb686f027a0739db309659068b386be86c176c4e6b4b12c50a47482d6a061fbc2cad993&mpshare=1&scene=1&srcid=&sharer_sharetime=1583798298072&sharer_shareid=778ad5bf3b27e0078eb105d7277263f6#rd







多图生动详解浏览器与Node环境下的 Event Loop

https://mp.weixin.qq.com/s?__biz=MzkwODIwMDY2OQ==&mid=2247488081&idx=1&sn=1a1ab442a2ea85d0cd4320f9c2125260&source=41#wechat_redirect



聊聊 JavaScript 的并发、异步和事件循环

https://musicfe.dev/eventloop/



图解javascript事件循环机制

https://tgideas.qq.com/gicp/news/475/7355255.html?from=list





图解 javascript 事件循环：微任务和宏任务

https://mp.weixin.qq.com/s/Fra63OYWVN4_rQehTn6o7w





js是单线程，但是浏览器是多线程









### 参考资料：

[JS：详解Event Loop运行机制](https://limeii.github.io/2019/05/js-eventloop/)