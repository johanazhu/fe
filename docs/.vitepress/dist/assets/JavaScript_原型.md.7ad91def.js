import{_ as s,c as a,o as n,d as p}from"./app.590c1fbf.js";const d=JSON.parse('{"title":"原型","description":"","frontmatter":{},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"统一概念","slug":"统一概念","link":"#统一概念","children":[]},{"level":2,"title":"名词解释","slug":"名词解释","link":"#名词解释","children":[{"level":3,"title":"prototype","slug":"prototype","link":"#prototype","children":[]},{"level":3,"title":"[[Prototype]] 和 __proto__","slug":"prototype-和-proto","link":"#prototype-和-proto","children":[]},{"level":3,"title":"prototype chain","slug":"prototype-chain","link":"#prototype-chain","children":[]},{"level":3,"title":"constructor","slug":"constructor","link":"#constructor","children":[]}]},{"level":2,"title":"创建对象和原型继承","slug":"创建对象和原型继承","link":"#创建对象和原型继承","children":[{"level":3,"title":"Object.setPrototypeOf","slug":"object-setprototypeof","link":"#object-setprototypeof","children":[]},{"level":3,"title":"Object.create","slug":"object-create","link":"#object-create","children":[]},{"level":3,"title":"隐式原型继承","slug":"隐式原型继承","link":"#隐式原型继承","children":[]},{"level":3,"title":"隐式原型继承和显式原型继承的互相转换","slug":"隐式原型继承和显式原型继承的互相转换","link":"#隐式原型继承和显式原型继承的互相转换","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"relativePath":"JavaScript/原型.md"}'),o={name:"JavaScript/原型.md"},e=p(`<h1 id="原型" tabindex="-1">原型 <a class="header-anchor" href="#原型" aria-hidden="true">#</a></h1><p>这篇文章将尝试回答这些问题：</p><ul><li><p>原型是什么</p></li><li><p>为什么要有原型</p></li><li><p>prototype 和 <code>__proto__</code> 有什么区别</p></li><li><p>原型链又是什么</p></li><li><p>原型是如何实现继承的</p></li><li><p>原型和原型链的关系如何</p></li></ul><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-hidden="true">#</a></h2><p>首先，JavaScript 是基于原型继承（Prototypal inheritance）的语言。原型（prototype）是给其他对象提供共享属性的对象，每个函数都有一个 prototype 属性，它指向的是一个 prototype 对象。每个对象都有一个隐式引用（[[Prototype]]），并且 [[Prototype]] 指向它的原型对象，并从中继承数据、结构和行为。同时原型对象同样拥有原型（函数也是对象，它也有[[Prototype]]），这样一层一层，最终指向 null，这种关系被称为原型链</p><p>从本质上说，原型是为实现继承的手段。既然 JavaScript 选择了这种方式实现，我们就有必要讨论原型继承是什么？它有什么优缺点以及它与类继承的区别，以及在 JavaScript 中其他继承方式</p><p>在文章开始，我们先统一一些概念问题，以便后文理解</p><h2 id="统一概念" tabindex="-1">统一概念 <a class="header-anchor" href="#统一概念" aria-hidden="true">#</a></h2><p>《JavaScript 高级程序设计第 4 版》介绍原型：</p><blockquote><p>无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数</p></blockquote><p>《JavaScript 高级程序设计第 4 版》英文版介绍原型：</p><blockquote><p>Whenever a function is created, its prototype property is also created according to a specific set of rules. By default, all prototypes automatically get a property called constructor that points back to the function on which it is a property.</p></blockquote><p><a href="https://tc39.es/ecma262/#sec-terms-and-definitions-prototype" target="_blank" rel="noreferrer">ECMA 规范</a>中如此定义原型：</p><blockquote><p>4.4.8 prototype</p><p>object that provides shared properties for other objects</p></blockquote><p>其被定义为：为其他对象提供共享属性的对象</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noreferrer">MDN</a> 介绍原型：</p><blockquote><p>遵循 ECMAScript 标准，<code>someObject.[[Prototype]]</code> 符号是用于指向 <code>someObject</code> 的原型。从 ECMAScript 6 开始，<code>[[Prototype]]</code> 可以通过 <code>Object.getPrototypeOf()</code>和 <code>Object.setPrototypeOf()</code>访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 <code>__proto__</code></p><p>但它不应该与构造函数 <code>func</code> 的 <code>prototype</code> 属性相混淆。被构造函数创建的实例对象的 <code>[[Prototype]]</code> 指向 <code>func</code> 的 <code>prototype</code> 属性。<strong><code>Object.prototype</code></strong> 属性表示 <code>Object</code> 的原型对象</p></blockquote><p>所以我们这样理解原型：</p><ul><li>又名 prototype，它的职责是给其它对象提供共享属性</li><li>从数据结构的角度看，它就是个单向链表</li><li>原型对象：每个函数都有一个 prototype 属性，这个属性是一个指针，指向一个对象，这个对象称为原型对象；每个对象都有一个 [[Prototype]] 属性，它同样是个指针，指向原型对象</li><li>原型属性：每个函数都有一个 prototype 属性，唤为原型属性，指向原型对象</li><li>所以原型、prototype 、原型对象、原型属性其实是一个东西的不同称呼，就像一个人在父母眼里是孩子，在儿女面前是爸妈，走在路上就是一个路人。当我们称呼这个东西为原型时，想表达的是它有什么作用；当我们称它为原型对象时，是因为每个对象在其创建时会自带 [[Prototype]] 属性，并指向它；当我们称它为原型属性时，是因为每个函数都会在创建时自带 prototype 属性，而且这个属性是个指针，指向了原型对象</li></ul><p>除此之外，还有一些概念：</p><ul><li>函数对象：所有 Function（内置构造函数） 的实例都是函数对象</li><li>普通对象：函数对象除外的均为普通对象</li><li>构造函数：又称构造器，英文名叫 constructor</li><li>隐式原型：<code>__proto__</code>，又名[[Prototype]]，它指向原型对象</li></ul><p>如此，我们统一了概念，接下来解释下什么是 prototype、为什么会有 prototype... 等等问题</p><h2 id="名词解释" tabindex="-1">名词解释 <a class="header-anchor" href="#名词解释" aria-hidden="true">#</a></h2><h3 id="prototype" tabindex="-1">prototype <a class="header-anchor" href="#prototype" aria-hidden="true">#</a></h3><blockquote><p>原型会让笔者想起《百年孤独》，一族六代人的家族故事。笔者至今还记得书中的一句话： 家族的第一个人被绑在树上，家族的最后一个人正被蚂蚁吃掉</p></blockquote><p>笔者为什么看到原型会想起《百年孤独》呢？因为笔者常被原型、原型对象、prototype、<code>__proto__</code> 、[[Prototype]] 等名词和概念搞晕，就好比《百年孤独》中的人物名，过段时间就分不清谁是谁了</p><p>无论是书还是规范，都有一个对原型的解释：</p><blockquote><p>JavaScript 的每个函数都有一个 prototype 属性，它指向原型对象；每个对象都有一个 [[Prototype]] 属性，它指向原型对象</p></blockquote><p>Give you an example</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Foo</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#FFCB6B;">Foo</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">johan</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">dir</span><span style="color:#A6ACCD;">(Foo)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">dir</span><span style="color:#A6ACCD;">(</span><span style="color:#FFCB6B;">Foo</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>打印之后：</p><p><img src="https://s2.loli.net/2022/07/25/z31py2ULonFY7Ag.png" alt="原型"></p><p>打印 Foo 的原型，看到了三个属性。而我们只赋值了 name，为什么会多两个参数呢？</p><p>实际上，语言底层帮我们实现了，无论是什么对象，只要一创建，就会自带 constructor 和 [[Prototype]]。而原型对象亦是对象，即 Foo.prototype 是对象，所以它也有 constructor 和 [[Prototype]]</p><p>当然，因为函数也是对象，所以它也有 constructor 和 [[Prototype]]</p><p><img src="https://s2.loli.net/2022/07/21/OGEeCoIad7L1DXB.png" alt="函数也是对象"></p><blockquote><p>这里需要说明：虽然在浏览器中打印 Foo 没看到 constructor 属性，但它确实存在，它指向 Function 内置构造函数</p></blockquote><p>这里我们可以确认一点，只要创建一个函数，函数就会自带 prototype 属性，它是个对象，并带有 [[Prototype]] 和 constructor 。那什么是 [[Prototype]] 呢</p><h3 id="prototype-和-proto" tabindex="-1">[[Prototype]] 和 <code>__proto__</code> <a class="header-anchor" href="#prototype-和-proto" aria-hidden="true">#</a></h3><p>前文例子中用 <code>Foo.__proto__</code> 来打印日志，而不是用 <code>Foo.[[Prototype]]</code>，而在打印 Foo 时，却看到隐式原型的名字是 [[Prototype]]，然而在其他文章中能看到<code>__proto__</code></p><p>实际上，无论是 [[Prototype]] ，还是 <code>__proto__</code>，指的都是同一个东西，在较早的文章中，为区分原型，我们叫它隐式原型。而它的出现，是一个历史问题</p><p>官方 ECMAScript 规定了 prototype 是个隐式引用，但是民间浏览器开了口子，实现了一个属性 <code>__proto__</code>，让实例对象可以通过 <code>__proto__</code> 访问原型对象。再后来官方只好向事实低头，将 <code>__proto__</code> 属性纳入规范中。后来在 ECMAScript 2015 提出了 getPrototypeOf() 及 setPrototypeOf() 方法来获取/设置原型对象</p><p>至于 [[Prototype]]，是在浏览器打印才显示的，它和 <code>__proto__</code> 是一个含义，只是浏览器厂商换了个马甲。而且我们能在开发者工具中查看到的 [[Prototype]]（或 <code>__proto__</code> ）是浏览器厂商故意渲染的一个虚拟节点。实际上并不存在该对象</p><p>所以 [[Prototype]] 属性既不能被 <code>for in</code> 遍历，也不能被 <code>Object.key(obj)</code> 查找出来</p><p>在前文中我们解释了每个对象都有 [[Prototype]] 属性，它指向原型对象，而原型对象也有自己的隐式引用（ [[Prototype]]），也有自己的原型对象，我们可以理解为父类对象。它的作用是当你在访问一个属性时，如果对象内部不存在这个属性，就会循着 [[Prototype]] 属性指向它的原型对象（父类对象）上查找，如果父类对象依然没有这个值，就会沿着父类对象的 [[Prototype]] 往它的父类对象上查找。以此类推，直到找到 null 为止。这一层层的追溯查找过程，就构成了原型链</p><h3 id="prototype-chain" tabindex="-1">prototype chain <a class="header-anchor" href="#prototype-chain" aria-hidden="true">#</a></h3><p>原型链是 prototype 和 [[Prototype]] 的结合形成的产物</p><p>Give you an example</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Person</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">Person</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sayName</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> johan </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Person</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">johan</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(johan</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sayName</span><span style="color:#A6ACCD;">())</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// &#39;johan&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(johan</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toString</span><span style="color:#A6ACCD;">())</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// &#39;[object Object]&#39;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><blockquote><p>这里涉及到继承、new 关键字，后文会再做说明，这里假设你已明白基础概念</p></blockquote><p>我们创建了一个构造函数 Person，在它的原型上创建一个方法 sayName，new Person 实例对象 johan，此时的 johan 属性上唯一的值就是 name</p><p><img src="https://s2.loli.net/2022/07/23/Hh3og24CwxKWYMm.png" alt="对象johan"></p><p>当我们使用方法 johan.sayName() 时，它在自有属性上找，找不到 sayName 方法，就沿着 [[Prototype]] 往它的原型对象上找，即 Person.prototype，在这里它找到了 sayName，调用它返回值</p><p><img src="https://s2.loli.net/2022/07/23/9KrqkOGWnJv6Hue.png" alt="Person.prototype"></p><p>当我们调用方法 johan.toString()，同样，自有属性上找，找不到沿着 [[Prototype]] 往它的原型对象上找，如上，还是找不到，就沿着 Person.prototype 的原型对象再往上找，即 <code>Person.prototype.__proto__</code>，在这里，找到了属性 toString，调用并返回值</p><p><img src="https://s2.loli.net/2022/07/23/5oytILr1h7jpzkS.png" alt="Person.prototype的原型对象"></p><p>如果你眼熟这上面的属性，就能明白它是 Object.prototype，也就是说</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">Person</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">__proto__ </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>即构造函数 Person 的原型继承自 Object.prototype</p><p>这就是原型链的作用，所以说 JavaScript 是基于原型继承的语言</p><p>所以依靠原型，就能实现继承，至于构造函数（constructor）它同样也能实现继承，不过是另一个话题了</p><h3 id="constructor" tabindex="-1">constructor <a class="header-anchor" href="#constructor" aria-hidden="true">#</a></h3><p>前文中一直有使用构造函数，它的作用是初始化对象，为对象成员变量赋初始值</p><p>关于 constructor ，我们能衍生出 constructor 的始祖 Function （内置构造函数）与 原型的始祖 Object.prototype 的鸡生蛋和蛋生鸡问题，具体可看这篇——<a href="./JavaScript中的始皇.html">JavaScript 中的始皇</a></p><p>也能通过盗用构造函数来实现继承，更能通过与原型的结合，实现更多可能的继承，具体所有的方法笔者会写在这篇——<a href="./继承.html">继承</a></p><p>不过在了解继承之前，不妨先看看原型继承</p><h2 id="创建对象和原型继承" tabindex="-1">创建对象和原型继承 <a class="header-anchor" href="#创建对象和原型继承" aria-hidden="true">#</a></h2><p>在讲 <a href="./Object.html">Object</a> 时，曾讲到对象的创建有三种方法，对象字面量、关键字 new、Object.create，而这三者都为原型继承</p><p>所谓的原型继承，无非是将一个对象设置为另一个对象的原型</p><p>在 JavaScript 中，有两类原型继承的方法：显式继承和隐式继承。两者的区别在于是否主动操作。像对象字面量、关键字 new 就是隐式继承，语言底层帮我们做了继承（正如前文第一个例子），像 Object.create，就是显式继承，需要开发者手动操作。除此之外，还有一种显式继承——Object.setPrototypeOf</p><h3 id="object-setprototypeof" tabindex="-1">Object.setPrototypeOf <a class="header-anchor" href="#object-setprototypeof" aria-hidden="true">#</a></h3><p>此方法设置一个特定的对象的原型到另一个对象或 null。ES6 新增方法。语法为：<code>Object.setPrototypeOf(obj, prototype)</code>。具体例子为：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obja </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> objb </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setPrototypeOf</span><span style="color:#A6ACCD;">(obja</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> objb)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(obja)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="https://s2.loli.net/2022/07/25/WeHJtA9mDkxGbRr.png" alt="Object.setPrototypeOf"></p><p>能看出，我们通过 Object.setPrototypeOf 方法，将 objb 设置为 obja 的原型，打印 obja 时，我们能看到 obja 的隐式原型（[[Prototype]]）指向 objb</p><p>除此之外，还有一个方法能显式继承原型——Object.create</p><h3 id="object-create" tabindex="-1">Object.create <a class="header-anchor" href="#object-create" aria-hidden="true">#</a></h3><p>它用于创建一个新对象，使用现有的对象作为新创建对象的原型。ES5 新增方法。它的语法是 <code>Object.create(proto, propertiesObject)</code> 。可看案例：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obja </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(obja)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(a)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="https://s2.loli.net/2022/07/25/f9Wo5jU46wLHgtc.png" alt="Object.create"></p><p>笔者在此之前曾写过一篇文章——<a href="./Object.create.html">Object.create</a>，介绍它是如何实现的，其底层就是用到了原型继承</p><p>我们对 Object.setPrototypeOf 和 Object.create 进行对比</p><ul><li>Object.setPrototypeOf，给我两个对象，将其中一个设置为另一个的原型</li><li>Object.create，给我一个对象，将它作为我所创建的新对象的原型</li></ul><p>从发展的角度看，Object.create 是 ES5 出现，但它不满足两个对象设置原型时，ES6 就提供了新的方法——Object.setPrototypeOf。但无论如何，它们都是后来因为个别需求而新增的 API，无法与 JavaScript 一开始采用的隐式继承相媲美</p><h3 id="隐式原型继承" tabindex="-1">隐式原型继承 <a class="header-anchor" href="#隐式原型继承" aria-hidden="true">#</a></h3><p>这里，我们不妨温习一下 <a href="./new做了什么.html">new</a> 实现原理：</p><ol><li>创建一个新对象</li><li>设置该对象的 [[Prototype]] 为构造函数 prototype 属性</li><li>将构造函数内部的 this 赋值给该对象</li><li>执行构造函数的内部代码</li><li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象</li></ol><p>这就是隐式继承，只要我们使用 new 创建对象，就会执行以上步骤，当然，用对象字面量是有一样的隐式操作</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{};</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// === new Object() 对象字面量</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> arr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> []</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// === new Array() 数组字面量</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">func</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//  new Function(); 函数字面量</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> str </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">123</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// === new Srting(&#39;123&#39;) 字符串字面量</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> bool </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// === new Boolean(true) 布尔字面量</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>JavaScript 提供了几个内置的构造函数，如 Object、Array、Boolean、String、Number 等等，当我们使用 <code>{}</code>、<code>[]</code>、<code>function</code> 等符号或关键字时，就是在执行与<code>new</code>操作一样的隐式原型继承</p><p>我们可以这样说：隐式原型继承的目的是方便开发者更简洁的实现继承</p><h3 id="隐式原型继承和显式原型继承的互相转换" tabindex="-1">隐式原型继承和显式原型继承的互相转换 <a class="header-anchor" href="#隐式原型继承和显式原型继承的互相转换" aria-hidden="true">#</a></h3><p>无论是隐式原型继承，还是显式原型继承，都是对对象隐式引用的应用。两者之间具有一定的互操作性，也就是说，用其中一个，能实现另一个的部分行为</p><p>例如我们用隐式原型继承实现 Object.create，实现上是手写 Object.create 方法，正如我们在 <a href="./Object.create.html">Object.create</a> 中曾实现的那样：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">create</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">proto</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">F</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">F</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">proto</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">F</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>原理也很简单，创建一个函数，将它的原型赋值为目标对象，在实例化这个函数，返回实例化后的值。new 实例化，相当于实例化的值的 [[Prototype]] 指向了目标对象</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">create</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">proto</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">F</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 创建一个函数，每个函数都有一个 prototype 属性，指向原型对象</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">F</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">proto</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 原本的 prototype 是一个对象，其中有两个属性，一个是 constructor，即构造函数，指向 F；另一个为 [[Prototype]]，指向 Object.prototype</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 现在将它赋值为 proto</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">F</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// new的作用是创建空对象，将该对象的原型赋值为另一个构造函数的 prototype 属性，并执行该构造函数</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 所以 new F() 后的实例的的[[Prototype]]指向 F.prototype，也就是传入的 proto</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>以上，我们就用 new 实现了显式原型继承</p><p>那么如何用显式原型继承实现 new （或者对象字面量）呢</p><p>我们在手写 <a href="./new做了什么.html">new</a> 中已经实现过，这里贴上代码：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">new2</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">Constructor</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">null</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 创建一个对象</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">__proto__</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Constructor</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 将新对象的 [[Prototype]] 属性赋值为构造函数的原型对象</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">result</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Constructor</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">apply</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">args</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// this赋值新对象并初始化</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">typeof</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">result</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">object</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">?</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">result</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 非空返回结果</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这也解释了面试时常考的两个面试题：手写 new 和手写 Object.create，两者一个是隐式原型继承，另一个是显式原型继承，两者间能通过各自特性实现对方方法</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><p>如此，我们就明白了原型是什么，原型与原型链的关系等等。而且我们知道 「JavaScript 是基于原型继承的语言」这句话的涵义。</p><p>虽然现在原型在面试中已经显得不重要，知乎上曾有过这样的问题——<a href="https://www.zhihu.com/question/60165921" target="_blank" rel="noreferrer">面试一个 5 年的前端，却连原型链也搞不清楚，满口都是 Vue，React 之类的实现，这样的人该用吗？</a>。不懂原型照样开发业务也很正常。笔者觉得这并不奇怪，毕竟前端的前端开发已经从面向对象转向函数式编程</p><p>在文末回答下文章开头的问题</p><p>Q：原型是什么？</p><p>A：给其他对象提供共享属性的对象</p><p>Q：为什么要有原型？</p><p>A： JavaScript 是基于原型继承的语言，在这里是为了实现继承</p><p>Q： prototype 和 <code>__proto__</code> 有什么区别</p><p>A： prototype 是函数特有的属性，每个函数创建时都会自带 prototype 属性，它指向一个对象，这个对象叫做原型对象。而每个对象都有一个 <code>__proto__</code> 属性，它也指向原型对象。如果说两者有什么关系？那么 子对象的<code>__proto__</code> === 父对象的 prototype</p><p>Q：原型链又是什么</p><p>A：每个对象都有 <code>__proto__</code> 属性，它指向原型对象，原型对象也是对象，也有 <code>__proto__</code> 属性，并指向它的原型对象，这样一层一层，最终指向 null，这种关系被称为原型链。</p><p>Q：原型是如何实现继承的</p><p>A：原型继承有四种方法，以是否手动操作为依据分为隐式原型继承和显式原型继承。隐式原型继承在我们开发中占大多数，即对象字面量和 new，即这两种方法语言底层会帮我们实现创建对象、关联原型和属性初始化。显式原型继承分为 Object.create 和 Object.setPrototypeOf，它能主动设置某个对象为另一个对象的原型</p><p>Q：原型和原型链的关系如何</p><p>A：原型是实现继承的方法，原型链是继承的产物</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-hidden="true">#</a></h2><ul><li><a href="https://mp.weixin.qq.com/s/1UDILezroK5wrcK-Z5bHOg" target="_blank" rel="noreferrer">深入理解 JavaScript 原型</a></li><li><a href="https://yanhaijing.com/javascript/2021/03/13/javascript-prototype-chain/" target="_blank" rel="noreferrer">如何回答面试中的 JavaScript 原型链问题</a></li></ul>`,120),l=[e];function t(r,c,i,y,F,D){return n(),a("div",null,l)}const C=s(o,[["render",t]]);export{d as __pageData,C as default};
