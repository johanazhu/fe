import{_ as l,c as s,o as a,d as n}from"./app.590c1fbf.js";const C=JSON.parse('{"title":"作用域 VS 执行上下文","description":"","frontmatter":{},"headers":[{"level":2,"title":"作用域","slug":"作用域","link":"#作用域","children":[]},{"level":2,"title":"执行上下文","slug":"执行上下文","link":"#执行上下文","children":[]}],"relativePath":"JavaScript/作用域与执行上下文.md"}'),e={name:"JavaScript/作用域与执行上下文.md"},i=n(`<h1 id="作用域-vs-执行上下文" tabindex="-1">作用域 VS 执行上下文 <a class="header-anchor" href="#作用域-vs-执行上下文" aria-hidden="true">#</a></h1><p>笔者在前文 <a href="./作用域.html">作用域</a> 、<a href="./执行上下文与调用栈.html">执行上下文</a> 中介绍过作用域和执行上下文，它们是 JavaScript 中很重要的知识点，是基础中的重点，是重点中的基础。</p><p>我们讲过 JavaScript 中的作用域是词法作用域，与在哪里定义有关；而执行上下文则和调用有关，两者有关联但却是不同概念</p><h2 id="作用域" tabindex="-1">作用域 <a class="header-anchor" href="#作用域" aria-hidden="true">#</a></h2><ul><li>作用域与哪里定义有关，在引擎编译时就知道它在哪里定义</li><li>其中函数作用域最为重要，因为作用域中的变量，作用域外不能访问，这起到了保护变量的作用</li><li>无生命周期</li><li>它可以理解为是“静态”的（词法作用域）</li><li>共全局作用域、函数作用域、块级作用域、eval 作用域</li></ul><h2 id="执行上下文" tabindex="-1">执行上下文 <a class="header-anchor" href="#执行上下文" aria-hidden="true">#</a></h2><ul><li>而执行上下文与调用有关</li><li>它表示一段代码执行时所带的所有信息 <ul><li>包括 this、词法环境、变量环境（ES5标准）</li><li>结合之前 <a href="./this关键字.html">this</a> 所给的定义：<strong>谁调用它，this 就指向谁</strong> 就是和执行上下文相关。执行上下文也是如此，与调用者息息相关</li></ul></li><li>生命周期为两个阶段 <ul><li>创建阶段 <ul><li>确定 this 指，即我们熟知的 this 绑定</li><li>创建变量环境 <ul><li>环境记录器 <ul><li>登记 var、function 等声明的变量</li><li>此时会发生变量提升和函数提升</li></ul></li><li>对外部环境的引用（outer） <ul><li>指向父作用域（作用域在代码执行前就确定了）</li></ul></li></ul></li><li>创建词法环境 <ul><li>环境记录器 <ul><li>登记 let、const 等声明的变量</li><li>会发生变量提升（hoist），但是不会被初始化，所以提前使用会报 ReferenceError，如例1所示</li></ul></li><li>对外部环境的引用（outer） <ul><li>同样指向父作用域</li></ul></li></ul></li></ul></li><li>执行阶段 <ul><li>指向代码</li><li>确定作用域链</li></ul></li></ul></li><li>它则是“动态”的（与调用方相关）</li><li>共全局执行上下文、函数执行上下文、模块执行上下文、eval 执行上下文</li></ul><p>例子1：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">a </span><span style="color:#676E95;font-style:italic;">// undefined</span></span>
<span class="line"><span style="color:#A6ACCD;">b </span><span style="color:#676E95;font-style:italic;">// ReferenceError</span></span>
<span class="line"><span style="color:#A6ACCD;">c </span><span style="color:#676E95;font-style:italic;">// ReferenceError</span></span>
<span class="line"><span style="color:#A6ACCD;">d </span><span style="color:#676E95;font-style:italic;">// function d() {}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> c </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">d</span><span style="color:#89DDFF;">(){}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>var 声明变量会被初始化为 undefined，一般函数（函数声明式写法）定义会被初始化为 <code>function xx(){}</code> ，let、const 则不会被初始化，所以 var 定义的变量可以提前使用但指为 undefined，一般函数定义可以正常提前使用，let、const 提前使用则会报错</p><blockquote><p>PS，如果使用函数表达式写法使用函数，则跟变量，如 var e = function(){} 或者 let f = () =&gt; {}</p></blockquote><p>以上就是作用域和指向上下文的各种区别</p>`,12),p=[i];function t(r,o,c,u,d,h){return a(),s("div",null,p)}const _=l(e,[["render",t]]);export{C as __pageData,_ as default};
