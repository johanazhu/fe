import{_ as e,c as t,o as a,d as i}from"./app.590c1fbf.js";const g=JSON.parse('{"title":"微信小程序开发","description":"","frontmatter":{},"headers":[{"level":2,"title":"双线程通信","slug":"双线程通信","link":"#双线程通信","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"relativePath":"WebApp/MiniApp/index.md"}'),r={name:"WebApp/MiniApp/index.md"},p=i('<h1 id="微信小程序开发" tabindex="-1">微信小程序开发 <a class="header-anchor" href="#微信小程序开发" aria-hidden="true">#</a></h1><p>小程序再架构方面最大的特点是采用了双线程的开发模式，隔离了 JS 逻辑和 UI 渲染。小程序的渲染层和逻辑层分别由 2 个线程管理：渲染层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS 脚本</p><p>逻辑层：创建一个单独的线程去执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码；</p><p>渲染层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程</p><p>通信：这两个渲染的通信会经由微信客户端做中转，逻辑层发送网络请求也经由 Native 转发，小程序的通信模型如下图所示：</p><p><img src="https://i.loli.net/2021/09/28/ZRA2KnthIVfDUaB.png" alt="小程序双线程架构"></p><h2 id="双线程通信" tabindex="-1">双线程通信 <a class="header-anchor" href="#双线程通信" aria-hidden="true">#</a></h2><p>用 JS 对象模拟 DOM 树 ——&gt; 比较两颗虚拟 DOM 树的差异 ——&gt; 把差异应用到真正的 DOM 树上</p><p>如图所示：</p><p><img src="https://i.loli.net/2021/09/28/sQwWnqmECUp5a4H.png" alt="双线程通信"></p><ol><li>在渲染层把 WXML 转化成对应的 JS 对象</li><li>在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到逻辑层</li><li>经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面</li></ol><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-hidden="true">#</a></h2><ul><li><p><a href="https://godbasin.github.io/2018/09/02/wxapp-technology-architecture/" target="_blank" rel="noreferrer">小程序的底层框架</a></p></li><li><p><a href="https://segmentfault.com/a/1190000019131399" target="_blank" rel="noreferrer">浅谈小程序运行机制</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/h562ECyLiQWkD3JpWXZg-g" target="_blank" rel="noreferrer">微信小程序基础架构浅析</a></p></li></ul>',13),l=[p];function n(s,o,h,c,d,_){return a(),t("div",null,l)}const m=e(r,[["render",n]]);export{g as __pageData,m as default};
