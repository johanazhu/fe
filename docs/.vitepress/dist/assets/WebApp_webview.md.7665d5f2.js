import{_ as e,c as a,o as p,d as i}from"./app.590c1fbf.js";const l=JSON.parse('{"title":"webview","description":"","frontmatter":{},"headers":[],"relativePath":"WebApp/webview.md"}'),r={name:"WebApp/webview.md"},h=i('<h1 id="webview" tabindex="-1">webview <a class="header-anchor" href="#webview" aria-hidden="true">#</a></h1><p>webview 的原理</p><p>如何实现 webview</p><h4 id="hybrid-是什么-为何会是用-hybrid" tabindex="-1">hybrid 是什么，为何会是用 hybrid？ <a class="header-anchor" href="#hybrid-是什么-为何会是用-hybrid" aria-hidden="true">#</a></h4><p>hybrid 即“混合”，即前端和客户端的混合开发</p><p>需要前端开发人员和客户端开发人员配合完成</p><p>某些环节也可能涉及到 server 端</p><h5 id="存在价值" tabindex="-1">存在价值 <a class="header-anchor" href="#存在价值" aria-hidden="true">#</a></h5><p>可以快速迭代更新【关键】（无需 app 审核）</p><h4 id="webview-1" tabindex="-1">webview <a class="header-anchor" href="#webview-1" aria-hidden="true">#</a></h4><p>是 app 中的一个组件（app 可以有 webview，也可以不要）</p><p>用于加载 h5 页面，即一个小型的浏览器内核</p><h4 id="file-协议" tabindex="-1">file 协议 <a class="header-anchor" href="#file-协议" aria-hidden="true">#</a></h4><p>https 协议（远程的），file 协议（文件协议，加载本地的）</p><p>file 协议：本地文件，快</p><p>http(s)协议：网络加载，慢</p><h4 id="具体实现" tabindex="-1">具体实现： <a class="header-anchor" href="#具体实现" aria-hidden="true">#</a></h4><p>前端做好页面，客户端开启 webview，用 file 协议加载静态页面</p><h4 id="完整流程" tabindex="-1">完整流程 <a class="header-anchor" href="#完整流程" aria-hidden="true">#</a></h4><p>分版本号</p><p>将静态文件压缩成 zip 包，上传到服务端</p><p>客户端每次启动，都去服务端检查版本号</p><p>如果服务端版本号与客户端不同，就去下载最新的包</p><p>下载完之后解压包，然后将现有文件覆盖</p><p>hybrid 和 H5 的区别</p><p>优点：体验更好，更 NA 体验基本一致</p><p>可快速迭代，无需 app 审核【关键】</p><p>缺点：开发成本高。联调、测试、查 bug 比较麻烦</p><p>运维成本高</p>',29),d=[h];function t(n,s,c,b,o,w){return p(),a("div",null,d)}const f=e(r,[["render",t]]);export{l as __pageData,f as default};
