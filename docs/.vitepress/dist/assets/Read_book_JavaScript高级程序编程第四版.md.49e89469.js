import{_ as a,c as i,o as e,d as l}from"./app.590c1fbf.js";const v=JSON.parse('{"title":"JavaScript 高级程序编程第四版","description":"","frontmatter":{},"headers":[{"level":2,"title":"第四章 变量、作用域与内存","slug":"第四章-变量、作用域与内存","link":"#第四章-变量、作用域与内存","children":[]},{"level":2,"title":"第六章 集合引用类型","slug":"第六章-集合引用类型","link":"#第六章-集合引用类型","children":[{"level":3,"title":"Map","slug":"map","link":"#map","children":[]}]},{"level":2,"title":"第八章 对象、类和面向对象编程","slug":"第八章-对象、类和面向对象编程","link":"#第八章-对象、类和面向对象编程","children":[]}],"relativePath":"Read/book/JavaScript高级程序编程第四版.md"}'),t={name:"Read/book/JavaScript高级程序编程第四版.md"},r=l('<h1 id="javascript-高级程序编程第四版" tabindex="-1">JavaScript 高级程序编程第四版 <a class="header-anchor" href="#javascript-高级程序编程第四版" aria-hidden="true">#</a></h1><h2 id="第四章-变量、作用域与内存" tabindex="-1">第四章 变量、作用域与内存 <a class="header-anchor" href="#第四章-变量、作用域与内存" aria-hidden="true">#</a></h2><p>JavaScript 变量可以保存两种类型的值：原始值和引用值。原始值可能是以下 6 种原始数据类型之 一：Undefined、Null、Boolean、Number、String 和 Symbol。原始值和引用值有以下特点。</p><ul><li>原始值大小固定，因此保存在栈内存上。</li><li>从一个变量到另一个变量复制原始值会创建该值的第二个副本。</li><li>引用值是对象，存储在堆内存上。</li><li>包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。</li><li>从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。</li><li>typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。</li></ul><p>任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个 上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结 如下。</p><ul><li>执行上下文分全局上下文、函数上下文和块级上下文。</li><li>代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。</li><li>函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃 至全局上下文中的变量。</li><li>全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。</li><li>变量的执行上下文用于确定什么时候释放内存。 JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript 的垃圾回收 程序可以总结如下。</li><li>离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。</li><li>主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。</li><li>引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript 引擎不再使用这种算 法，但某些旧版本的 IE 仍然会受这种算法的影响，原因是 JavaScript 会访问非原生 JavaScript 对 象（如 DOM 元素）。</li><li>引用计数在代码中存在循环引用时会出现问题。</li><li>解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对 象、全局对象的属性和循环引用都应该在不需要时解除引用</li></ul><h2 id="第六章-集合引用类型" tabindex="-1">第六章 集合引用类型 <a class="header-anchor" href="#第六章-集合引用类型" aria-hidden="true">#</a></h2><h3 id="map" tabindex="-1">Map <a class="header-anchor" href="#map" aria-hidden="true">#</a></h3><p>与 Object 只能使用数值、字符串或符号作为键不同， Map 可以使用任何 JavaScript 数据类型作为键</p><h2 id="第八章-对象、类和面向对象编程" tabindex="-1">第八章 对象、类和面向对象编程 <a class="header-anchor" href="#第八章-对象、类和面向对象编程" aria-hidden="true">#</a></h2><ul><li>每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法</li><li>无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数</li><li>理解：是个函数就有 prototype，原型对象 === 这个函数的 prototype</li></ul>',11),c=[r];function n(p,d,o,h,s,_){return e(),i("div",null,c)}const S=a(t,[["render",n]]);export{v as __pageData,S as default};
