import{_ as e,c as a,o as s,d as n}from"./app.590c1fbf.js";const F=JSON.parse('{"title":"React 面试题","description":"","frontmatter":{},"headers":[{"level":2,"title":"常见问题","slug":"常见问题","link":"#常见问题","children":[{"level":3,"title":"Q：渲染十万条数据解决方案","slug":"q-渲染十万条数据解决方案","link":"#q-渲染十万条数据解决方案","children":[]},{"level":3,"title":"Q：请问 Fiber 是什么？","slug":"q-请问-fiber-是什么","link":"#q-请问-fiber-是什么","children":[]},{"level":3,"title":"Q： React Fiber 和之前的 15 有什么区别","slug":"q-react-fiber-和之前的-15-有什么区别","link":"#q-react-fiber-和之前的-15-有什么区别","children":[]},{"level":3,"title":"Q：函数式组件和类组件有什么区别","slug":"q-函数式组件和类组件有什么区别","link":"#q-函数式组件和类组件有什么区别","children":[]}]},{"level":2,"title":"组件","slug":"组件","link":"#组件","children":[{"level":3,"title":"Q：函数式组件与 class 组件的区别","slug":"q-函数式组件与-class-组件的区别","link":"#q-函数式组件与-class-组件的区别","children":[]},{"level":3,"title":"Q： React 有哪几种创建组件的方式？有什么区别","slug":"q-react-有哪几种创建组件的方式-有什么区别","link":"#q-react-有哪几种创建组件的方式-有什么区别","children":[]},{"level":3,"title":"Q： React 组件间有哪些通讯方式？","slug":"q-react-组件间有哪些通讯方式","link":"#q-react-组件间有哪些通讯方式","children":[]},{"level":3,"title":"Q：父组件如何调用子组件中的方法？","slug":"q-父组件如何调用子组件中的方法","link":"#q-父组件如何调用子组件中的方法","children":[]},{"level":3,"title":"Q： React 是如何区分 class 和 function 的？","slug":"q-react-是如何区分-class-和-function-的","link":"#q-react-是如何区分-class-和-function-的","children":[]}]},{"level":2,"title":"性能优化","slug":"性能优化","link":"#性能优化","children":[{"level":3,"title":"Q：在 React 中可以做哪些性能优化","slug":"q-在-react-中可以做哪些性能优化","link":"#q-在-react-中可以做哪些性能优化","children":[]},{"level":3,"title":"Q：请问 React/ Vue 之类的框架为什么需要给组件添加 key 属性，其作用是什么？","slug":"q-请问-react-vue-之类的框架为什么需要给组件添加-key-属性-其作用是什么","link":"#q-请问-react-vue-之类的框架为什么需要给组件添加-key-属性-其作用是什么","children":[]}]},{"level":2,"title":"state & setState","slug":"state-setstate","link":"#state-setstate","children":[{"level":3,"title":"Q：请问 setState 是异步还是同步？为什么？","slug":"q-请问-setstate-是异步还是同步-为什么","link":"#q-请问-setstate-是异步还是同步-为什么","children":[]},{"level":3,"title":"Q：什么事件可以触发异步，什么会触发同步？","slug":"q-什么事件可以触发异步-什么会触发同步","link":"#q-什么事件可以触发异步-什么会触发同步","children":[]},{"level":3,"title":"Q：调用 setState 之后发生了什么","slug":"q-调用-setstate-之后发生了什么","link":"#q-调用-setstate-之后发生了什么","children":[]},{"level":3,"title":"Q：在 shouldComponentUpdate 或 componentWillUpdate 中使用 setState 会发生什么？","slug":"q-在-shouldcomponentupdate-或-componentwillupdate-中使用-setstate-会发生什么","link":"#q-在-shouldcomponentupdate-或-componentwillupdate-中使用-setstate-会发生什么","children":[]},{"level":3,"title":"Q：为什么不能直接使用 this.state 改变数据","slug":"q-为什么不能直接使用-this-state-改变数据","link":"#q-为什么不能直接使用-this-state-改变数据","children":[]}]},{"level":2,"title":"Hooks","slug":"hooks","link":"#hooks","children":[{"level":3,"title":"Q：你对 Hooks 了解吗？Hooks 的本质是什么？为什么？","slug":"q-你对-hooks-了解吗-hooks-的本质是什么-为什么","link":"#q-你对-hooks-了解吗-hooks-的本质是什么-为什么","children":[]},{"level":3,"title":"Q：为什么不能在循环中调用 hooks？或者说为什么不能在 for 循环、if 语句里使用 hooks？","slug":"q-为什么不能在循环中调用-hooks-或者说为什么不能在-for-循环、if-语句里使用-hooks","link":"#q-为什么不能在循环中调用-hooks-或者说为什么不能在-for-循环、if-语句里使用-hooks","children":[]},{"level":3,"title":"Q： React hooks，它带来了哪些便利","slug":"q-react-hooks-它带来了哪些便利","link":"#q-react-hooks-它带来了哪些便利","children":[]},{"level":3,"title":"Q：列举几个常用的 Hook","slug":"q-列举几个常用的-hook","link":"#q-列举几个常用的-hook","children":[]},{"level":3,"title":"Q：说下 React hooks 实现原理","slug":"q-说下-react-hooks-实现原理","link":"#q-说下-react-hooks-实现原理","children":[]},{"level":3,"title":"Q： React Hooks 当中的 useEffect 是如何区分生命周期钩子的","slug":"q-react-hooks-当中的-useeffect-是如何区分生命周期钩子的","link":"#q-react-hooks-当中的-useeffect-是如何区分生命周期钩子的","children":[]},{"level":3,"title":"Q： useEffect(fn, []) 和 componentDidMount 有什么差异","slug":"q-useeffect-fn-和-componentdidmount-有什么差异","link":"#q-useeffect-fn-和-componentdidmount-有什么差异","children":[]},{"level":3,"title":"Q: Hooks 和 hoc 的区别，为什么不用 hoc","slug":"q-hooks-和-hoc-的区别-为什么不用-hoc","link":"#q-hooks-和-hoc-的区别-为什么不用-hoc","children":[]},{"level":3,"title":"Q: useMemo，useCallback 的区别，你是如何看待这两个 api 的意义，在什么场景下会使用它","slug":"q-usememo-usecallback-的区别-你是如何看待这两个-api-的意义-在什么场景下会使用它","link":"#q-usememo-usecallback-的区别-你是如何看待这两个-api-的意义-在什么场景下会使用它","children":[]},{"level":3,"title":"Q: 为什么 useState 不能在判断语句中声明？","slug":"q-为什么-usestate-不能在判断语句中声明","link":"#q-为什么-usestate-不能在判断语句中声明","children":[]}]},{"level":2,"title":"Virtual DOM","slug":"virtual-dom","link":"#virtual-dom","children":[{"level":3,"title":"Q： React 的 Virtual dom 是怎么实现的？","slug":"q-react-的-virtual-dom-是怎么实现的","link":"#q-react-的-virtual-dom-是怎么实现的","children":[]},{"level":3,"title":"Q：考虑过 React 、 Vue 这类的框架为什么要用 Virtual DOM 机制吗？","slug":"q-考虑过-react-、-vue-这类的框架为什么要用-virtual-dom-机制吗","link":"#q-考虑过-react-、-vue-这类的框架为什么要用-virtual-dom-机制吗","children":[]},{"level":3,"title":"Q：为什么 Virtual dom 会提高性能？","slug":"q-为什么-virtual-dom-会提高性能","link":"#q-为什么-virtual-dom-会提高性能","children":[]}]},{"level":2,"title":"diff","slug":"diff","link":"#diff","children":[{"level":3,"title":"Q：简单介绍下 diff 算法","slug":"q-简单介绍下-diff-算法","link":"#q-简单介绍下-diff-算法","children":[]}]},{"level":2,"title":"React 中的事件机制","slug":"react-中的事件机制","link":"#react-中的事件机制","children":[{"level":3,"title":"Q：简述下 React 的事件代理机制","slug":"q-简述下-react-的事件代理机制","link":"#q-简述下-react-的事件代理机制","children":[]},{"level":3,"title":"Q： React 的事件代理机制和原生事件绑定有什么区别？","slug":"q-react-的事件代理机制和原生事件绑定有什么区别","link":"#q-react-的事件代理机制和原生事件绑定有什么区别","children":[]},{"level":3,"title":"Q： React 的事件代理机制和原生事件绑定混用会有什么问题？","slug":"q-react-的事件代理机制和原生事件绑定混用会有什么问题","link":"#q-react-的事件代理机制和原生事件绑定混用会有什么问题","children":[]},{"level":3,"title":"Q： React 中如果绑定事件使用匿名函数会怎么样？","slug":"q-react-中如果绑定事件使用匿名函数会怎么样","link":"#q-react-中如果绑定事件使用匿名函数会怎么样","children":[]}]},{"level":2,"title":"生态相关","slug":"生态相关","link":"#生态相关","children":[{"level":3,"title":"Q： Redux 是什么","slug":"q-redux-是什么","link":"#q-redux-是什么","children":[]},{"level":3,"title":"Q：请问 Redux 的原理是什么？你能手写一个 Redux 吗？","slug":"q-请问-redux-的原理是什么-你能手写一个-redux-吗","link":"#q-请问-redux-的原理是什么-你能手写一个-redux-吗","children":[]},{"level":3,"title":"Q： React-redux 的实现原理","slug":"q-react-redux-的实现原理","link":"#q-react-redux-的实现原理","children":[]},{"level":3,"title":"Q: react-redux 中 connect 实现原理","slug":"q-react-redux-中-connect-实现原理","link":"#q-react-redux-中-connect-实现原理","children":[]},{"level":3,"title":"Q： Redux 和 mobx 的区别","slug":"q-redux-和-mobx-的区别","link":"#q-redux-和-mobx-的区别","children":[]},{"level":3,"title":"Q： Redux 异步中间件有什么用？","slug":"q-redux-异步中间件有什么用","link":"#q-redux-异步中间件有什么用","children":[]},{"level":3,"title":"Q：请问 React.Router 的模式","slug":"q-请问-react-router-的模式","link":"#q-请问-react-router-的模式","children":[]},{"level":3,"title":"Q：请问 Dva 的知识点？与 namespce 同层的参数有哪些？","slug":"q-请问-dva-的知识点-与-namespce-同层的参数有哪些","link":"#q-请问-dva-的知识点-与-namespce-同层的参数有哪些","children":[]}]},{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[{"level":3,"title":"Q：简述下 React 的生命周期？每个声明周期都做了什么？","slug":"q-简述下-react-的生命周期-每个声明周期都做了什么","link":"#q-简述下-react-的生命周期-每个声明周期都做了什么","children":[]}]},{"level":2,"title":"其他","slug":"其他","link":"#其他","children":[{"level":3,"title":"Q：请问 React 从本页面跳转至其他站点页是否会执行 unmount？为什么","slug":"q-请问-react-从本页面跳转至其他站点页是否会执行-unmount-为什么","link":"#q-请问-react-从本页面跳转至其他站点页是否会执行-unmount-为什么","children":[]},{"level":3,"title":"Q：请问 React 中的 错误捕获","slug":"q-请问-react-中的-错误捕获","link":"#q-请问-react-中的-错误捕获","children":[]},{"level":3,"title":"Q：为什么 constructor 里要调用 super 和传递 props？","slug":"q-为什么-constructor-里要调用-super-和传递-props","link":"#q-为什么-constructor-里要调用-super-和传递-props","children":[]},{"level":3,"title":"Q：为什么调用方法要 bind this？","slug":"q-为什么调用方法要-bind-this","link":"#q-为什么调用方法要-bind-this","children":[]},{"level":3,"title":"Q： React 中的 ref 是干嘛的？","slug":"q-react-中的-ref-是干嘛的","link":"#q-react-中的-ref-是干嘛的","children":[]},{"level":3,"title":"Q：什么是 Portals？","slug":"q-什么是-portals","link":"#q-什么是-portals","children":[]},{"level":3,"title":"Q：什么是 suspense 组件？","slug":"q-什么是-suspense-组件","link":"#q-什么是-suspense-组件","children":[]},{"level":3,"title":"Q：为什么 React 元素有一个 $$typeof 属性？","slug":"q-为什么-react-元素有一个-typeof-属性","link":"#q-为什么-react-元素有一个-typeof-属性","children":[]},{"level":3,"title":"Q：为什么 JSX 中的组件名要以大写字母开头","slug":"q-为什么-jsx-中的组件名要以大写字母开头","link":"#q-为什么-jsx-中的组件名要以大写字母开头","children":[]},{"level":3,"title":"Q： React 17、React 18 有什么新的特性","slug":"q-react-17、react-18-有什么新的特性","link":"#q-react-17、react-18-有什么新的特性","children":[]},{"level":3,"title":"Q：请问 React 有什么坑点？","slug":"q-请问-react-有什么坑点","link":"#q-请问-react-有什么坑点","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"relativePath":"React/面试题/index.md"}'),l={name:"React/面试题/index.md"},t=n(`<h1 id="react-面试题" tabindex="-1">React 面试题 <a class="header-anchor" href="#react-面试题" aria-hidden="true">#</a></h1><p>知乎上有个问题：<a href="https://www.zhihu.com/question/29191974/answer/1620274467" target="_blank" rel="noreferrer">如果进阿里前端，代码能力得达到什么程度？</a></p><p>阿里官方的回答中，如果是个数量掌握 React 前端框架，了解技术底层的话，中高级的要求点是：</p><ul><li>能说明白为什么要实现 fiber，以及可能带来的坑</li><li>能说明白为什么要实现 hook</li><li>能说明白为什么要用 immutable，以及用或者不用的考虑</li><li>知道 react 不常用的特性，比如 context，portal</li><li>能用自己的理解说明白 react like 框架的本质，能说明白如何让这些框架共存</li><li>能设计出框架无关的技术架构。包括但不限于：</li><li>说明如何解决可能存在的冲突问题，需要结合实际案例。</li><li>能说明架构分层逻辑、各层的核心模块，以及核心模块要解决的问题。能结合实际场景例举一些坑或者优雅的处理方案则更佳</li><li>看过全家桶源码，不要求每行都看，但是知道核心实现原理和底层依赖。能口喷几行关键代码把对应类库实现即达标</li><li>能从数据驱动角度透彻的说明白 redux，能够口喷原生 js 和 redux 结合要怎么做</li><li>能结合 redux，vuex，mobx 等数据流谈谈自己对 vue 和 react 的异同</li><li>有基于全家桶构建复杂应用的经验，比如最近很火的微前端和这些类库结合的时候要注意什么，会有什么坑，怎么解决</li></ul><p>一看，我就慌的一批，这就是中高级前端的标准，你达标了吗？</p><h2 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-hidden="true">#</a></h2><h3 id="q-渲染十万条数据解决方案" tabindex="-1">Q：渲染十万条数据解决方案 <a class="header-anchor" href="#q-渲染十万条数据解决方案" aria-hidden="true">#</a></h3><p>A：<a href="./渲染十万条数据解决方案.html">渲染十万条数据解决方案</a></p><h3 id="q-请问-fiber-是什么" tabindex="-1">Q：请问 Fiber 是什么？ <a class="header-anchor" href="#q-请问-fiber-是什么" aria-hidden="true">#</a></h3><p>A： React Fiber 是对核心算法的一次重新实现。16 和 15 的区别，如下。它有三层含义，作为架构，作为静态数据结构，作为动态工作单位</p><h3 id="q-react-fiber-和之前的-15-有什么区别" tabindex="-1">Q： React Fiber 和之前的 15 有什么区别 <a class="header-anchor" href="#q-react-fiber-和之前的-15-有什么区别" aria-hidden="true">#</a></h3><p>A： React 在 V16 之前会面临的主要性能问题是：当组件很庞大时，更新状态可能造成页面卡顿，根本原因在于——更新流程是【同步、不可中断的】</p><p>为了解决这个问题，React 重写了代码，提出了 Fiber 架构，它是异步可中断的</p><h3 id="q-函数式组件和类组件有什么区别" tabindex="-1">Q：函数式组件和类组件有什么区别 <a class="header-anchor" href="#q-函数式组件和类组件有什么区别" aria-hidden="true">#</a></h3><p>A：最大的区别在于函数式组件会捕获渲染时的值</p><p>具体可以看这篇文章——<a href="./../函数式组件与类组件有何不同.html">函数式组件与类组件有何不同</a></p><h2 id="组件" tabindex="-1">组件 <a class="header-anchor" href="#组件" aria-hidden="true">#</a></h2><h3 id="q-函数式组件与-class-组件的区别" tabindex="-1">Q：函数式组件与 class 组件的区别 <a class="header-anchor" href="#q-函数式组件与-class-组件的区别" aria-hidden="true">#</a></h3><p>A：最大的区别在于函数式组件会捕获渲染时的值</p><p>具体可以看这篇文章——<a href="./../函数式组件与类组件有何不同.html">函数式组件与类组件有何不同</a></p><h3 id="q-react-有哪几种创建组件的方式-有什么区别" tabindex="-1">Q： React 有哪几种创建组件的方式？有什么区别 <a class="header-anchor" href="#q-react-有哪几种创建组件的方式-有什么区别" aria-hidden="true">#</a></h3><p>A：函数式组件、类组件、createElement</p><p>PS：这个问题已经淘汰，以前的函数组件是没有状态的，但现在 16.8 之后就有 hook，函数式组件也有状态；反而类组件没多少人写了，因为生命周期很麻烦，也难记</p><h3 id="q-react-组件间有哪些通讯方式" tabindex="-1">Q： React 组件间有哪些通讯方式？ <a class="header-anchor" href="#q-react-组件间有哪些通讯方式" aria-hidden="true">#</a></h3><p>A：四种，父传子（props），子传父（props 回调），跨组件（context），非嵌套组件通信（事件订阅）</p><h3 id="q-父组件如何调用子组件中的方法" tabindex="-1">Q：父组件如何调用子组件中的方法？ <a class="header-anchor" href="#q-父组件如何调用子组件中的方法" aria-hidden="true">#</a></h3><p>A：一般都是子组件调用父组件的方法，那有什么办法让父组件调用子组件的方法？分两种场景</p><ul><li>类组件 <ul><li>createRef</li></ul></li><li>函数式组件 <ul><li>forwardRef + useImperativeHandle</li></ul></li></ul><h3 id="q-react-是如何区分-class-和-function-的" tabindex="-1">Q： React 是如何区分 class 和 function 的？ <a class="header-anchor" href="#q-react-是如何区分-class-和-function-的" aria-hidden="true">#</a></h3><p>A：在 Component 的 prototype 上有 isReactComponent ，函数式组件没有</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// React 内部</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Component</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#FFCB6B;">Component</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">isReactComponent </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{};</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-hidden="true">#</a></h2><h3 id="q-在-react-中可以做哪些性能优化" tabindex="-1">Q：在 React 中可以做哪些性能优化 <a class="header-anchor" href="#q-在-react-中可以做哪些性能优化" aria-hidden="true">#</a></h3><p>列表项使用 key 属性</p><p>类组件</p><ul><li><p>shouldComponentUpdate 避免不必要的渲染</p><ul><li>true：当前组件进行 render</li><li>false：当前组件不进行 render</li><li>用法：shouldComponentUpdate(nextProps, nextState)</li></ul></li><li><p>将函数绑定放在构造函数、或者在定义阶段使用箭头函数绑定，可以笔名每次都绑定事件</p></li><li><p>PureComponent 会对 props 和 state 进行前对比</p></li></ul><p>函数式组件</p><ul><li><p>memo 避免不必要的渲染</p><ul><li>与 shouldComponentUpdate 相反，如果 props 相等，areEqual 会返回 true；如果 props 不相等，则返回 false</li></ul></li><li><p>useMemo、useCallback</p><ul><li>useMemo 返回缓存的值</li><li>useCallback 返回缓存的函数</li></ul></li></ul><h3 id="q-请问-react-vue-之类的框架为什么需要给组件添加-key-属性-其作用是什么" tabindex="-1">Q：请问 React/ Vue 之类的框架为什么需要给组件添加 key 属性，其作用是什么？ <a class="header-anchor" href="#q-请问-react-vue-之类的框架为什么需要给组件添加-key-属性-其作用是什么" aria-hidden="true">#</a></h3><p>A：唯一性，diff 算法</p><h2 id="state-setstate" tabindex="-1">state &amp; setState <a class="header-anchor" href="#state-setstate" aria-hidden="true">#</a></h2><h3 id="q-请问-setstate-是异步还是同步-为什么" tabindex="-1">Q：请问 setState 是异步还是同步？为什么？ <a class="header-anchor" href="#q-请问-setstate-是异步还是同步-为什么" aria-hidden="true">#</a></h3><p>A：代码是同步的，但是渲染要看模式，在 legacy 模式下，非原生事件、setTimeout/setInterval 等情况下为异步；addEventListener 绑定的原生事件、setTimeout/setInterval 同步；而在未来的 concurrent 模式下（V18 模式使用），都为异步</p><p>为什么？为了提高性能，React 会采用批处理的方案</p><h3 id="q-什么事件可以触发异步-什么会触发同步" tabindex="-1">Q：什么事件可以触发异步，什么会触发同步？ <a class="header-anchor" href="#q-什么事件可以触发异步-什么会触发同步" aria-hidden="true">#</a></h3><p>A：非原生事件、非 setTimeout/setInterval 会触发异步；原生事件、setTimeout/setInterval 会触发同步</p><h3 id="q-调用-setstate-之后发生了什么" tabindex="-1">Q：调用 setState 之后发生了什么 <a class="header-anchor" href="#q-调用-setstate-之后发生了什么" aria-hidden="true">#</a></h3><p>A：（在 legacy 模式下）调用 setState 后，会将修改的回调函数放入执行队列中，当此事件中的 setState 全部调用完，会批处理合成 setState，并依次触发 static getDerivedStateFromProps、shouldComponentUpdate、render、getSnapshotBeforeUpdate、componentDidUpdate 等生命周期</p><h3 id="q-在-shouldcomponentupdate-或-componentwillupdate-中使用-setstate-会发生什么" tabindex="-1">Q：在 shouldComponentUpdate 或 componentWillUpdate 中使用 setState 会发生什么？ <a class="header-anchor" href="#q-在-shouldcomponentupdate-或-componentwillupdate-中使用-setstate-会发生什么" aria-hidden="true">#</a></h3><p>A：禁止在 shouldComponentUpdate 和 componentWillUpdate 中调用 setState，为什么，这回造成循环调用，直至内存崩溃。 setState 会触发 React 的更新机制，好让视图更新，会依次触发生命周期函数，而 shouldComponentUpdate 、componentWillUpdate 都是必过的生命周期，会造成循环调用（PS： componentWillUpdate 未来版本会不用）</p><h3 id="q-为什么不能直接使用-this-state-改变数据" tabindex="-1">Q：为什么不能直接使用 this.state 改变数据 <a class="header-anchor" href="#q-为什么不能直接使用-this-state-改变数据" aria-hidden="true">#</a></h3><p>A：修改值不改变视图，setState 不仅是修改 this.state 的值，更重要的是它会触发 React 的更新机制，会进行 diff，然后将 patch 部分更新到真实 DOM 中</p><h2 id="hooks" tabindex="-1">Hooks <a class="header-anchor" href="#hooks" aria-hidden="true">#</a></h2><h3 id="q-你对-hooks-了解吗-hooks-的本质是什么-为什么" tabindex="-1">Q：你对 Hooks 了解吗？Hooks 的本质是什么？为什么？ <a class="header-anchor" href="#q-你对-hooks-了解吗-hooks-的本质是什么-为什么" aria-hidden="true">#</a></h3><p>A： React Hooks 是 React 16.8 之后推出的函数式组件状态管理方案。它是为了解决状态复用、类组件写法麻烦等原因而提出的</p><p>本质是什么？闭包</p><h3 id="q-为什么不能在循环中调用-hooks-或者说为什么不能在-for-循环、if-语句里使用-hooks" tabindex="-1">Q：为什么不能在循环中调用 hooks？或者说为什么不能在 for 循环、if 语句里使用 hooks？ <a class="header-anchor" href="#q-为什么不能在循环中调用-hooks-或者说为什么不能在-for-循环、if-语句里使用-hooks" aria-hidden="true">#</a></h3><p>A：因为 hooks 中的状态是以链表形式存在，如果使用 for 循环、if 语句，会使得后续的状态没法更新</p><h3 id="q-react-hooks-它带来了哪些便利" tabindex="-1">Q： React hooks，它带来了哪些便利 <a class="header-anchor" href="#q-react-hooks-它带来了哪些便利" aria-hidden="true">#</a></h3><p>A：逻辑复用、业务代码更聚合、写法更简洁</p><h3 id="q-列举几个常用的-hook" tabindex="-1">Q：列举几个常用的 Hook <a class="header-anchor" href="#q-列举几个常用的-hook" aria-hidden="true">#</a></h3><p>A： useState、useEffect、useRef、useCallback、useMemo、useReducer、useLayoutEffect 等</p><h3 id="q-说下-react-hooks-实现原理" tabindex="-1">Q：说下 React hooks 实现原理 <a class="header-anchor" href="#q-说下-react-hooks-实现原理" aria-hidden="true">#</a></h3><p>A：闭包、Fiber、链表</p><p>Hooks 主要是利用闭包来保存状态，使用链表保存一系列 Hooks，将链表中的第一个 Hook 与 Fiber 关联。在 Fiber 树更新时，就能从 Hooks 中计算出最终输出的状态和执行相关的副作用</p><h3 id="q-react-hooks-当中的-useeffect-是如何区分生命周期钩子的" tabindex="-1">Q： React Hooks 当中的 useEffect 是如何区分生命周期钩子的 <a class="header-anchor" href="#q-react-hooks-当中的-useeffect-是如何区分生命周期钩子的" aria-hidden="true">#</a></h3><p>A：第二个参数为空数组，简单来说是依赖项为空</p><h3 id="q-useeffect-fn-和-componentdidmount-有什么差异" tabindex="-1">Q： useEffect(fn, []) 和 componentDidMount 有什么差异 <a class="header-anchor" href="#q-useeffect-fn-和-componentdidmount-有什么差异" aria-hidden="true">#</a></h3><p>A： useEffect 会捕获 props 和 state。即使在回调函数里，你拿到的还是初始的 props 和 state。如果你想要得到“最新”的值，你可以使用 ref。不过通常会有更简单的实现方式，所以你并不一定要用 ref。记住，effects 的心智模型和 componentDidMount 以及其他生命周期是不同的，试图找到它们之间完全一致的表达反而更容易是你混淆。想要更有效，你需要“think in effects”，它的心智模型更接近于实现状态同步，而不是响应生命周期 ——Dan</p><h4 id="执行时机不同" tabindex="-1">执行时机不同 <a class="header-anchor" href="#执行时机不同" aria-hidden="true">#</a></h4><p>componentDidMount 在组件挂载之后运行。如果立即（同步）设置 state，那么 React 就会触发一次额外的 render，并将第二个 render 的响应作为初始 UI，</p><p>useEffect 也是在挂载后运行，但是它更往后，它不会阻塞真实 DOM 渲染，因为 useEffect 在绘制（Paint）之后异步运行。</p><h4 id="props-和-state-的捕获-capture-value" tabindex="-1">Props 和 State 的捕获（Capture Value） <a class="header-anchor" href="#props-和-state-的捕获-capture-value" aria-hidden="true">#</a></h4><p>每次渲染就会捕获新的 props 和 state</p><h3 id="q-hooks-和-hoc-的区别-为什么不用-hoc" tabindex="-1">Q: Hooks 和 hoc 的区别，为什么不用 hoc <a class="header-anchor" href="#q-hooks-和-hoc-的区别-为什么不用-hoc" aria-hidden="true">#</a></h3><p>A: 通常，render props 和 高阶组件只渲染一个子节点。我们认为让 Hook 来服务这个使用场景更加简单。这两种模式仍有用户之地（例如一个虚拟滚动条组件或许会有一个 <code>renderItem</code> 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。</p><p>hoc 的缺点是会有嵌套、props 会被劫持，容易出现冲突，Hooks 没有个问题</p><h3 id="q-usememo-usecallback-的区别-你是如何看待这两个-api-的意义-在什么场景下会使用它" tabindex="-1">Q: useMemo，useCallback 的区别，你是如何看待这两个 api 的意义，在什么场景下会使用它 <a class="header-anchor" href="#q-usememo-usecallback-的区别-你是如何看待这两个-api-的意义-在什么场景下会使用它" aria-hidden="true">#</a></h3><p>A: useMemo 缓存值，useCallback 缓存函数。两个函数的用法很像</p><h3 id="q-为什么-usestate-不能在判断语句中声明" tabindex="-1">Q: 为什么 useState 不能在判断语句中声明？ <a class="header-anchor" href="#q-为什么-usestate-不能在判断语句中声明" aria-hidden="true">#</a></h3><p>A：官网里写了只在最顶层使用 Hooks。不要在循环，条件或嵌套函数中调用 Hook，确保总是在你的 React 函数的最顶层以及任何 return 之前调用他们。</p><p>state 是以链表的数据结构存在，多个 state 之间同构 next 进行关联。假设有 3 个 state，A、B、C。如果 B 在判断语句中，那么就会出现 A，B 的状态能够及时更新，但是 C 不会更新。因为调用 2 次 useState，只会更新两次 state，在 state 的链表中，A.next -&gt;B，B.next -&gt; C，那么就只会更新 A、B。C 不会更新，导致一些不可预知的问题</p><h2 id="virtual-dom" tabindex="-1">Virtual DOM <a class="header-anchor" href="#virtual-dom" aria-hidden="true">#</a></h2><h3 id="q-react-的-virtual-dom-是怎么实现的" tabindex="-1">Q： React 的 Virtual dom 是怎么实现的？ <a class="header-anchor" href="#q-react-的-virtual-dom-是怎么实现的" aria-hidden="true">#</a></h3><p>A： React 是把真实的 DOM 树转换为 JS 对象树，也就是 Virtual DOM。每次数据更新后，重新计算 VM，并和上一次生成的 VM 树进行对比，对发生变化的部分进行批量更新。除了性能之外，VM 的实现最大的好处在于和其他平台的集成。</p><p>虚拟 DOM 的本质是 JavaScript 对象，它可以代表真实 DOM 的抽象表示。通过预先操作虚拟 DOM，在某个时机找出与真实 DOM 之间的差异并重新渲染，来提升真实 DOM 的性能和效率</p><h3 id="q-考虑过-react-、-vue-这类的框架为什么要用-virtual-dom-机制吗" tabindex="-1">Q：考虑过 React 、 Vue 这类的框架为什么要用 Virtual DOM 机制吗？ <a class="header-anchor" href="#q-考虑过-react-、-vue-这类的框架为什么要用-virtual-dom-机制吗" aria-hidden="true">#</a></h3><p>A：为了减少不必要的 DOM 渲染、跨平台、为函数式的 UI 编程打开了大门</p><h3 id="q-为什么-virtual-dom-会提高性能" tabindex="-1">Q：为什么 Virtual dom 会提高性能？ <a class="header-anchor" href="#q-为什么-virtual-dom-会提高性能" aria-hidden="true">#</a></h3><p>A：因为 VM 并不是真实的操作 DOM，通过 diff 算法可以避免一些不变更的 DOM 操作，从而提高性能</p><p>但是不一定会提高性能，他只是通过 diff 算法笔名了一些不需要变更的 DOM 操作，但最终还是要操作 DOM 的，并且 diff 的过程也需要成本</p><h2 id="diff" tabindex="-1">diff <a class="header-anchor" href="#diff" aria-hidden="true">#</a></h2><h3 id="q-简单介绍下-diff-算法" tabindex="-1">Q：简单介绍下 diff 算法 <a class="header-anchor" href="#q-简单介绍下-diff-算法" aria-hidden="true">#</a></h3><p>A：本来涉及到两棵树的对比，时间复杂度是 O(n^3)。为了降低时间复杂度，React 基于两个假设条件（启发式算法 O(n) ）：</p><ul><li>相同类型的组件产生相同的 DOM 结构，反之不同类型的元素会产生不同的树</li><li>同一层级的一组节点，可以通过唯一标识符进行区分</li></ul><h2 id="react-中的事件机制" tabindex="-1">React 中的事件机制 <a class="header-anchor" href="#react-中的事件机制" aria-hidden="true">#</a></h2><h3 id="q-简述下-react-的事件代理机制" tabindex="-1">Q：简述下 React 的事件代理机制 <a class="header-anchor" href="#q-简述下-react-的事件代理机制" aria-hidden="true">#</a></h3><p>A：初始化渲染时在 root 节点上注册原生事件；原生事件触发时模拟捕获、目标和冒泡阶段派发合成事件。通过这种机制，冒泡的原生事件类型最多在 root 节点上注册一次，节省内存凯西奥</p><h3 id="q-react-的事件代理机制和原生事件绑定有什么区别" tabindex="-1">Q： React 的事件代理机制和原生事件绑定有什么区别？ <a class="header-anchor" href="#q-react-的事件代理机制和原生事件绑定有什么区别" aria-hidden="true">#</a></h3><p>A： React 的事件代理机制是框架写的合成事件</p><h3 id="q-react-的事件代理机制和原生事件绑定混用会有什么问题" tabindex="-1">Q： React 的事件代理机制和原生事件绑定混用会有什么问题？ <a class="header-anchor" href="#q-react-的事件代理机制和原生事件绑定混用会有什么问题" aria-hidden="true">#</a></h3><p>A：</p><h3 id="q-react-中如果绑定事件使用匿名函数会怎么样" tabindex="-1">Q： React 中如果绑定事件使用匿名函数会怎么样？ <a class="header-anchor" href="#q-react-中如果绑定事件使用匿名函数会怎么样" aria-hidden="true">#</a></h3><p>A：</p><h2 id="生态相关" tabindex="-1">生态相关 <a class="header-anchor" href="#生态相关" aria-hidden="true">#</a></h2><h3 id="q-redux-是什么" tabindex="-1">Q： Redux 是什么 <a class="header-anchor" href="#q-redux-是什么" aria-hidden="true">#</a></h3><p>A：一个状态管理库，一般和 react 搭配使用。遵循单向数据流的开发模式。用户通过 action 发起 dispatch ，通过 reducer 返回新的 store。reducer 是一个纯函数，传入 store 后会输出 store</p><h3 id="q-请问-redux-的原理是什么-你能手写一个-redux-吗" tabindex="-1">Q：请问 Redux 的原理是什么？你能手写一个 Redux 吗？ <a class="header-anchor" href="#q-请问-redux-的原理是什么-你能手写一个-redux-吗" aria-hidden="true">#</a></h3><p>A：</p><h3 id="q-react-redux-的实现原理" tabindex="-1">Q： React-redux 的实现原理 <a class="header-anchor" href="#q-react-redux-的实现原理" aria-hidden="true">#</a></h3><p>A：</p><h3 id="q-react-redux-中-connect-实现原理" tabindex="-1">Q: react-redux 中 connect 实现原理 <a class="header-anchor" href="#q-react-redux-中-connect-实现原理" aria-hidden="true">#</a></h3><p>A:</p><h3 id="q-redux-和-mobx-的区别" tabindex="-1">Q： Redux 和 mobx 的区别 <a class="header-anchor" href="#q-redux-和-mobx-的区别" aria-hidden="true">#</a></h3><p>A：</p><h3 id="q-redux-异步中间件有什么用" tabindex="-1">Q： Redux 异步中间件有什么用？ <a class="header-anchor" href="#q-redux-异步中间件有什么用" aria-hidden="true">#</a></h3><p>A：</p><h3 id="q-请问-react-router-的模式" tabindex="-1">Q：请问 React.Router 的模式 <a class="header-anchor" href="#q-请问-react-router-的模式" aria-hidden="true">#</a></h3><p>A：共三种模式，手写一个</p><h3 id="q-请问-dva-的知识点-与-namespce-同层的参数有哪些" tabindex="-1">Q：请问 Dva 的知识点？与 namespce 同层的参数有哪些？ <a class="header-anchor" href="#q-请问-dva-的知识点-与-namespce-同层的参数有哪些" aria-hidden="true">#</a></h3><p>A：</p><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-hidden="true">#</a></h2><h3 id="q-简述下-react-的生命周期-每个声明周期都做了什么" tabindex="-1">Q：简述下 React 的生命周期？每个声明周期都做了什么？ <a class="header-anchor" href="#q-简述下-react-的生命周期-每个声明周期都做了什么" aria-hidden="true">#</a></h3><p>A：类组件才有的概念。一般分为挂载时，更新时，卸载时、错误时三块，</p><p>挂载时（Mount）：constructor、getDerivedStateFromProps 、render、componentDidMount、</p><p>更新时（Update）：getDerivedStateFromProps、shouldComponentUpdate、render、getSnapshotBeforeUpdate、componentDidUpdate</p><p>卸载时（Unmount）：componentWillUnmount</p><p>错误时（Error）：getDerivedStateFromError、componentDidCatch</p><p><img src="https://s2.loli.net/2022/03/04/ha3NcqybKZ24QkP.png" alt="image-20220304145136362"></p><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-hidden="true">#</a></h2><h3 id="q-请问-react-从本页面跳转至其他站点页是否会执行-unmount-为什么" tabindex="-1">Q：请问 React 从本页面跳转至其他站点页是否会执行 unmount？为什么 <a class="header-anchor" href="#q-请问-react-从本页面跳转至其他站点页是否会执行-unmount-为什么" aria-hidden="true">#</a></h3><p>A：不会，做过实验。</p><h3 id="q-请问-react-中的-错误捕获" tabindex="-1">Q：请问 React 中的 错误捕获 <a class="header-anchor" href="#q-请问-react-中的-错误捕获" aria-hidden="true">#</a></h3><p>A： getDerivedStateFromError：用来处理错误、componentDidCatch：输出完整的错误信息</p><p>try / catch 仅能用于命令式代码（imperative code）,但是 react 组件是声明式的，所以需要错误边界来捕捉错误</p><h3 id="q-为什么-constructor-里要调用-super-和传递-props" tabindex="-1">Q：为什么 constructor 里要调用 super 和传递 props？ <a class="header-anchor" href="#q-为什么-constructor-里要调用-super-和传递-props" aria-hidden="true">#</a></h3><p>A：这是官网的一段代码，具体见：<a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noreferrer">状态（State） 和 生命周期</a></p><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Clock</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">React</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">Component</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">props</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">super</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">props</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> date</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Date</span><span style="color:#F07178;">() </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">render</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">Hello, World!</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">h2</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">It is </span><span style="color:#89DDFF;">{this.</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">date</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toLocalTimeString</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">h2</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">        )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>而且有这么一段话，不仅让我们调用 <code>super</code> 还要把 <code>props</code> 传递进去，但是没有告诉我们为什么要这么做。</p><p>不知道你有没有疑惑为什么要调用 <code>super</code> 和传递 <code>props</code>，接下来我们来揭开谜题吧</p><p><strong>为什么要调用 super</strong></p><p>其实这不是 React 的限制，这是 JavaScript 的限制，在构造函数里如果要调用 this，那么提前就要调用 super，在 React 里，我们常常会在构造函数里初始化 state ，<code>this.state = xxx</code> ,所以需要调用 super</p><p><strong>为什么要传递 props</strong></p><p>你可以能以为必须给 <code>super</code> 传入 <code>props</code> ,否则 <code>React.Component</code> 就没办法初始化 <code>this.props</code></p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Component</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">props</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">props</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>不过，如果你不小心漏传了 <code>props</code> ，直接调用了 <code>super()</code> ，你仍然可以在 <code>render</code> 和其他方法中访问 <code>this.props</code></p><p>难道这样也行？<strong>因为 React 会在构造函数被调用之后，会把 props 赋值给刚刚创建的实例对象</strong></p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> instance </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">YourComponent</span><span style="color:#A6ACCD;">(props)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">instance</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">props </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> props</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>props</code> 不传也能用，是有原因的。</p><p>但这意味着你在使用 React 时，可以用 <code>super()</code> 代替 <code>super(props)</code> 了么？</p><p>那还是不行的，不然官网也不会建议你调用 props 了，虽然 React 会在构造函数运行之后，为 <code>this.props</code> 赋值，但在 <code>super()</code> 调用之后与构造函数结束之前， <code>this.props</code> 仍然是没法用的</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Component</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">props</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">props</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">props</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Button</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">React</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">Component</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">props</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">super</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 没有传入 props</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">props</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// {}</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">props</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// undefined</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>要是构造函数中调用了某个访问 <code>props</code> 的方法，那这个 bug 就更难定位了。因此我强烈建议始终使用 super(props)，即使这不是必须的：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Button</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">React</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">Component</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">props</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">super</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">props</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//  传入 props</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">props</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//  {}</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">props</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//  {}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="q-为什么调用方法要-bind-this" tabindex="-1">Q：为什么调用方法要 bind this？ <a class="header-anchor" href="#q-为什么调用方法要-bind-this" aria-hidden="true">#</a></h3><p>A：四种写实践的写法</p><h3 id="q-react-中的-ref-是干嘛的" tabindex="-1">Q： React 中的 ref 是干嘛的？ <a class="header-anchor" href="#q-react-中的-ref-是干嘛的" aria-hidden="true">#</a></h3><p>A：操作实例或 DOM 的 API</p><h3 id="q-什么是-portals" tabindex="-1">Q：什么是 Portals？ <a class="header-anchor" href="#q-什么是-portals" aria-hidden="true">#</a></h3><p>A：传送门，能在指定的 dom 上渲染组件</p><h3 id="q-什么是-suspense-组件" tabindex="-1">Q：什么是 suspense 组件？ <a class="header-anchor" href="#q-什么是-suspense-组件" aria-hidden="true">#</a></h3><p>A：一般和 lazy 结合，在页面加载出来前渲染</p><h3 id="q-为什么-react-元素有一个-typeof-属性" tabindex="-1">Q：为什么 React 元素有一个 <code>$$typeof</code> 属性？ <a class="header-anchor" href="#q-为什么-react-元素有一个-typeof-属性" aria-hidden="true">#</a></h3><p>A： Dan 写的<a href="https://overreacted.io/zh-hans/why-do-react-elements-have-typeof-property/" target="_blank" rel="noreferrer">一篇文章</a>，是为了防止 XSS 攻击。因为 JSON 不支持 Symbol 类型，所以服务器通过 JSON 攻击不会影响到 React</p><h3 id="q-为什么-jsx-中的组件名要以大写字母开头" tabindex="-1">Q：为什么 JSX 中的组件名要以大写字母开头 <a class="header-anchor" href="#q-为什么-jsx-中的组件名要以大写字母开头" aria-hidden="true">#</a></h3><p>A：判断当前渲染的元素是组件还是 HTML 元素</p><h3 id="q-react-17、react-18-有什么新的特性" tabindex="-1">Q： React 17、React 18 有什么新的特性 <a class="header-anchor" href="#q-react-17、react-18-有什么新的特性" aria-hidden="true">#</a></h3><p>A： concurrent 模式，异步可中断</p><h3 id="q-请问-react-有什么坑点" tabindex="-1">Q：请问 React 有什么坑点？ <a class="header-anchor" href="#q-请问-react-有什么坑点" aria-hidden="true">#</a></h3><p>A：</p><ol><li>JSX 做表达式判断时，需要强转未 boolean 类型，如：</li></ol><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">b</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    	</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">        	</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;">!!</span><span style="color:#A6ACCD;">b </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">这是一段文字</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">    )</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>如果不使用!!b 进行强转数据类型，会在页面里面输出 0</p><ol start="2"><li>如果 key 不变，数据就不会变，如果两列数据为[1, 2, 3] ,[1, 2, 3, 4, 5, 6]点击第一组数据中的任意项，此数据标红，且展示第二组数据，如果展示 UI 时，key 为 index，那么前三是不会被替换的，你看的会是数据标红了且是第二条数据</li></ol><p>react 中 onClick={fun}和 onClick=&gt;{()=&gt;fun}有何区别呢？</p><p><a href="https://www.zhihu.com/question/504049336/answer/2294252770?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=56197411504128&amp;utm_content=group3_Answer&amp;utm_campaign=shareopn" target="_blank" rel="noreferrer">https://www.zhihu.com/question/504049336/answer/2294252770?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=56197411504128&amp;utm_content=group3_Answer&amp;utm_campaign=shareopn</a></p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-hidden="true">#</a></h2><ul><li><a href="https://www.zhihu.com/question/29191974/answer/1620274467" target="_blank" rel="noreferrer">如果进阿里前端，代码能力得达到什么程度？</a></li><li><a href="https://juejin.cn/post/6940287134154637326" target="_blank" rel="noreferrer">金三银四 React 常见面试题</a></li><li><a href="https://github.com/yacan8/blog/issues/18" target="_blank" rel="noreferrer">一年半经验，百度、有赞、阿里前端面试总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/304213203" target="_blank" rel="noreferrer">React 灵魂 23 问，你能答对几个？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&amp;mid=2247484614&amp;idx=1&amp;sn=a2b5050136c2cd5e00db90a6cc8daaed&amp;chksm=ea0167aadd76eebc0af31bf8de9ee7e5a35ecdb9e19045f5f36a0e5f8e3ae28e25e58eec0994&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1567645123897&amp;sharer_shareid=778ad5bf3b27e0078eb105d7277263f6#rd" target="_blank" rel="noreferrer">新手学习 react 迷惑的点(完整版)</a></li></ul>`,178),r=[t];function p(o,c,i,d,h,u){return s(),a("div",null,r)}const D=e(l,[["render",p]]);export{F as __pageData,D as default};
