import{_ as e,c as r,o as i,d as a}from"./app.590c1fbf.js";const u=JSON.parse('{"title":"浏览器架构","description":"","frontmatter":{},"headers":[{"level":2,"title":"写在面前","slug":"写在面前","link":"#写在面前","children":[]},{"level":2,"title":"一句话解释","slug":"一句话解释","link":"#一句话解释","children":[]},{"level":2,"title":"早期的浏览器","slug":"早期的浏览器","link":"#早期的浏览器","children":[]},{"level":2,"title":"多进程架构","slug":"多进程架构","link":"#多进程架构","children":[]},{"level":2,"title":"未来的面向服务的架构","slug":"未来的面向服务的架构","link":"#未来的面向服务的架构","children":[]},{"level":2,"title":"如何查看进程","slug":"如何查看进程","link":"#如何查看进程","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"Q&A","slug":"q-a","link":"#q-a","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"relativePath":"Browser/浏览器架构.md"}'),l={name:"Browser/浏览器架构.md"},t=a('<h1 id="浏览器架构" tabindex="-1">浏览器架构 <a class="header-anchor" href="#浏览器架构" aria-hidden="true">#</a></h1><h2 id="写在面前" tabindex="-1">写在面前 <a class="header-anchor" href="#写在面前" aria-hidden="true">#</a></h2><p>从浏览器的发展轨迹上看，最开始的浏览器是单进程的（猜测是因为硬件问题），它们不稳定、不流畅且不安全（单线程的问题），后来有了 Chrome，创造性地引入了多进程架构，并解决了这些遗留问题，开创了多进程浏览器架构。Chrome 正在尝试应用更多的业务场景，比如移动设备， VR，视频等等，为了支持它们， Chrome 的体系结构变得越来越复杂，最终他们选择了面向服务（SOA）的体系结构</p><h2 id="一句话解释" tabindex="-1">一句话解释 <a class="header-anchor" href="#一句话解释" aria-hidden="true">#</a></h2><p>现代浏览器是由什么组成的？</p><p>看是什么版本的。在 18 年，是由 1 个浏览器主进程、1 个 GPU 进程、多个渲染进程、多个插件进程组成，19 年的 Chrome 多了网络进程，目前又多了音频进程、存储进程等等</p><h2 id="早期的浏览器" tabindex="-1">早期的浏览器 <a class="header-anchor" href="#早期的浏览器" aria-hidden="true">#</a></h2><p>我们讲过 <a href="./../CSBasic/进程与线程.html">进程与线程</a> 的关系。进程就是应用程序创建的实例，而线程依托于进程。他们的关系：</p><ul><li>进程中的任意一线程执行出错，会导致整个进程的奔溃</li><li>线程之间共享进程中的数据</li><li>当一个进程关闭之后，操作系统会回收进程所占用的内存</li><li>进程之间的内容相互隔离（很好地设计模型）</li></ul><p>在早年，<strong>浏览器的架构是单进程的</strong>。顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等</p><p>所有的模块都在一个进程中，只要一个进程出错，整个进程就会奔溃。</p><p>总之，单进程的浏览器存在着<strong>不稳定</strong>（插件开多了，容易奔溃）、不流畅（JavaScript 是单线程，执行会导致页面“卡”住）、<strong>不安全</strong>（插件使用 C/C++编写，意味着可以被插件控制）</p><h2 id="多进程架构" tabindex="-1">多进程架构 <a class="header-anchor" href="#多进程架构" aria-hidden="true">#</a></h2><p>为了解决单进程的缺点，Chrome 浏览器采用了多进程架构。</p><p><img src="https://i.loli.net/2021/04/08/ncHPaq13yEGXMVY.png" alt="chrome浏览器架构"></p><p>最终 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、网络（NetWork）进程、多个渲染进程和多个插件进程</p><p>下面我们来逐个分析下这几个进程的功能。</p><ul><li><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能</li><li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下</li><li><strong>GPU 进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程</li><li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程</li><li><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</li></ul><p>先说屁话，懂的都懂，字面意思</p><p>多进程架构怎么就解决了单进程架构的缺点呢？</p><p><strong>解决不稳定</strong>：我打开一个页面，就是开启一个渲染进程，这个页面奔溃了，只要把它关掉即可，不会影响其他页面</p><p><strong>解决不流畅</strong>：同理，打开一个页面，就是开启一个渲染进程，无论这个页面多卡（再说一次，JavaScript 是单线程语言，就是指一次只能完成一件任务，要是执行过程中阻塞住就会影响到页面），卡的是这个页面，不会影响其他页面</p><p>顺便一说，对于内存泄漏的解决方法也就更简单了，因为当关闭一个页面时，整个渲染进程页会被关闭，之后该进程所占用的内容都会被系统回收，也就解决了浏览器的内容泄漏问题</p><p><strong>解决不安全</strong>：渲染进程和插进进程都使用了沙箱，沙箱里面的程序可以运行，但不能再你的硬盘上写入任何数据，也不能在敏感位置读取任何数据。说白了，沙箱就是你可以使用，但并不能修改</p><p>虽然多进程架构提高了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题</p><ul><li><strong>更高的资源占用</strong>。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li><li><strong>更复杂的体系架构</strong>。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了</li></ul><h2 id="未来的面向服务的架构" tabindex="-1">未来的面向服务的架构 <a class="header-anchor" href="#未来的面向服务的架构" aria-hidden="true">#</a></h2><p>现代浏览器的问题是资源占用高、体系架构又复杂。为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。简单来说，是想构建一个更内聚、松耦合、易于维护和扩展的系统</p><p>Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图</p><p><img src="https://i.loli.net/2021/04/08/jq7odUmM9nIB5ZA.png" alt="未来chrome浏览器架构"></p><p>即一个模块就是一个服务，而这些服务，未来如果采用这种架构，那么开启一个 Chrome 后，要开启十几个进程，当然，这些进程占用的内存会更小</p><h2 id="如何查看进程" tabindex="-1">如何查看进程 <a class="header-anchor" href="#如何查看进程" aria-hidden="true">#</a></h2><p>你可以点击 Chrome 浏览器右上角的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开 Chrome 的任务管理器的窗口，如下图：</p><p><img src="https://i.loli.net/2021/04/08/LT47a1MI8KOe9EZ.png" alt="2021chrome浏览器架构.png"></p><p>俺的 Chrome 版本是 89.0.4389.90，并且下了不少插件，不太直观。我们也可以看看 Edge 的：</p><p><img src="https://i.loli.net/2021/04/08/wThiYNMVQXzvqZg.png" alt="2021edge浏览器架构.png"></p><p>可以看出，无论是 Chrome 还是 Edge，在 2021 年都比以前多了 Storage Service 。Chrome 还有</p><p>Audio Service ，V8 代理解析工具，备用渲染程序</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><p>现代浏览器是由什么组成的？</p><p>看是什么版本的，在 18 年是是由 1 个浏览器主进程、1 个 GPU 进程、多个渲染进程、多个插件进程组成，19 年的 Chrome 多了网络进程，目前又多了音频进程、存储进程等等</p><p>考虑到”进程就是应用程序创建的实例“，所以你打开 Chrome ，就意味着开启至少 5 个进程，而进程中的线程一旦出错，进程就奔溃</p><p>一个渲染进程是由多个线程组成，而这些线程又如何影响到进程的呢？关于这个知识点我们后续会谈一下</p><p>顺便一说：渲染进程中包括 JS 引擎线程、事件触发线程、网络异步线程、定时器线程</p><h2 id="q-a" tabindex="-1">Q&amp;A <a class="header-anchor" href="#q-a" aria-hidden="true">#</a></h2><p>Q：如果打开了 2 个页面，会有几个进程呢？是 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 2 个渲染进程，共 5 个吗？这些进程是可以在浏览器开发者中被实际观察到的吗？</p><p>A：通常情况下会是五个，但是有很多其他情况：</p><ol><li>如果页面里有 iframe 的话，iframe 也会运行在单独的进程中！</li><li>如果页面里有插件，同样插件也需要开启一个单独的进程！</li><li>如果你装了扩展的话，扩展也会占用进程</li><li>如果 2 个页面属于同一站点的话，并且从 a 页面中打开的 b 页面，那么他们会公用一个渲染进程</li></ol><p>这些进程都可以通过 chrome 的任务管理器来查看</p><p>Q：老师，渲染进程中有哪些线程呢？查了好多资料，感觉前后冲突。有说渲染进程中有网络线程，不知道这个网络线程和网络进程是不是一个东西呢？</p><p>A： Chrome 的渲染线程中没有网络线程！</p><p>估计看的是老的浏览器资料吧，在单进程浏览器架构中：渲染引擎，网络加载，等都是运行在同一个进程中！</p><p>不过现代浏览器已经将网络模块剥离出来了，有的以线程形式运行在浏览器主进程中的，有的像最新版本 Chrome 已经将网络功能单独独立出来一个进程来执行了！</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-hidden="true">#</a></h2><ul><li><a href="https://time.geekbang.org/column/article/132931" target="_blank" rel="noreferrer">浏览器工作原理与实践</a></li></ul>',55),h=[t];function n(p,o,s,d,c,g){return i(),r("div",null,h)}const _=e(l,[["render",n]]);export{u as __pageData,_ as default};
