import{_ as s,c as a,o as n,d as e}from"./app.590c1fbf.js";const A=JSON.parse('{"title":"ES6 面试题","description":"","frontmatter":{},"headers":[{"level":3,"title":"Q：箭头函数和普通函数有什么区别？","slug":"q-箭头函数和普通函数有什么区别","link":"#q-箭头函数和普通函数有什么区别","children":[]},{"level":3,"title":"Q： class B 继承 class A 翻译成 es5 应该是什么样子","slug":"q-class-b-继承-class-a-翻译成-es5-应该是什么样子","link":"#q-class-b-继承-class-a-翻译成-es5-应该是什么样子","children":[]},{"level":3,"title":"Q: 为什么子类的构造函数，一定要调用super()？","slug":"q-为什么子类的构造函数-一定要调用super","link":"#q-为什么子类的构造函数-一定要调用super","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"relativePath":"ES6/面试题/index.md"}'),l={name:"ES6/面试题/index.md"},p=e(`<h1 id="es6-面试题" tabindex="-1">ES6 面试题 <a class="header-anchor" href="#es6-面试题" aria-hidden="true">#</a></h1><h3 id="q-箭头函数和普通函数有什么区别" tabindex="-1">Q：箭头函数和普通函数有什么区别？ <a class="header-anchor" href="#q-箭头函数和普通函数有什么区别" aria-hidden="true">#</a></h3><ul><li>箭头函数没有自己的 this 对象，函数体内的 this 是定义时所在的对象而不是使用时所在的对象</li><li>不可以当作构造函数，也就是说，不可以对箭头函数使用 new 命令，否者会抛出一个错误</li><li>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替（<a href="./../ES6完全指南.html">ES6 完全指南</a>）</li><li>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数（<a href="./../Iterator&amp;Generator.html">迭代器与生成器</a>）</li></ul><h3 id="q-class-b-继承-class-a-翻译成-es5-应该是什么样子" tabindex="-1">Q： class B 继承 class A 翻译成 es5 应该是什么样子 <a class="header-anchor" href="#q-class-b-继承-class-a-翻译成-es5-应该是什么样子" aria-hidden="true">#</a></h3><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">A</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">B</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">A</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">B</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(</span><span style="color:#FFCB6B;">A</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">B</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">constructor </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> B</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="q-为什么子类的构造函数-一定要调用super" tabindex="-1">Q: 为什么子类的构造函数，一定要调用<code>super()</code>？ <a class="header-anchor" href="#q-为什么子类的构造函数-一定要调用super" aria-hidden="true">#</a></h3><p>A: 原因就在于 ES6 的继承机制，与 ES5 完全不同。ES5 的继承机制，是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。ES6 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。这就是为什么 ES6 的继承必须先调用<code>super()</code>方法，因为这一步会生成一个继承父类的<code>this</code>对象，没有这一步就无法继承父类。</p><p>JavaScript | 你常用的 Array Methods 是我常用的嗎？</p><p><a href="https://medium.com/starbugs/javascript-%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84-array-methods-%E6%98%AF%E6%88%91%E5%B8%B8%E7%94%A8%E7%9A%84%E5%97%8E-6fe235953951" target="_blank" rel="noreferrer">https://medium.com/starbugs/javascript-你常用的-array-methods-是我常用的嗎-6fe235953951</a></p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-hidden="true">#</a></h2>`,10),r=[p];function o(t,c,i,d,h,F){return n(),a("div",null,r)}const D=s(l,[["render",o]]);export{A as __pageData,D as default};
