import{_ as s,c as n,o as a,d as l}from"./app.590c1fbf.js";const b=JSON.parse('{"title":"let 和 const","description":"","frontmatter":{},"headers":[{"level":2,"title":"let 和 const","slug":"let-和-const-1","link":"#let-和-const-1","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"relativePath":"ES6/Let&Const.md"}'),p={name:"ES6/Let&Const.md"},e=l(`<h1 id="let-和-const" tabindex="-1">let 和 const <a class="header-anchor" href="#let-和-const" aria-hidden="true">#</a></h1><h2 id="let-和-const-1" tabindex="-1">let 和 const <a class="header-anchor" href="#let-和-const-1" aria-hidden="true">#</a></h2><p>默认使用 const，只有当确实需要改变变量的值的时候才使用 let。这是因为大部分的变量的值在初始化后不应再改变，而预料之外的变量的修改是很多 bug 的源头</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// bad</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> foo </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">bar</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// good</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> foo </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">bar</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// better</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> foo </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">bar</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>let 和 const 引起块作用域。在 ES6 之前，只有两种作用域（全局作用域和函数作用域，eval 作用域不算）。</p><p>let 和 const 不会引起变量提升，会有<strong>暂时性死区</strong></p><p>这个要说到代码执行过程，分两个阶段，</p><ul><li>代码预编译阶段</li><li>代码执行阶段</li></ul><p><strong>预编译阶段是前置阶段，这个时候由编译器将 JS 代码变异成可执行的代码</strong></p><p><strong>执行阶段主要任务是执行代码，执行上下文在这个阶段全部创建完成</strong>。</p><p>在通过语法分析，确认语法无误之后，JS 带啊在预编译阶段对变量的内存空间进行分配，我们熟悉的变量提升过程在此阶段完成。</p><p>预编译阶段应注意三点：</p><ul><li>预编译阶段进行变量声明；</li><li>预编译阶段变量声明进行提升，但值为 undefined；</li><li>预编译阶段所有非表达式的函数声明进行提升</li></ul><p>之前说到暂时性死区和“变量提升”有关，看以下代码</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>会输出：<code>undefined</code> ，原因是变量 bar 在函数内进行了提升。相当于：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bar</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这里多说一句，这是在预编译阶段执行的“伪代码”，当 foo() 执行时，就是第二阶段，执行代码</p><p>但在这里使用 let 声明时：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>会报错：Uncaught ReferenceError: bar is not defined。</p><p>我们知道使用<code>let</code> 或 <code>const</code> 声明变量，会针对这个变量形成一个封闭的块级作用域，在这个会计作用域当中，如果在声明变量钱访问该变量，就会报 <code>referenceError</code> 错误；如果在声明变量后访问，则可以正常获取变量值：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">bar</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>正常输出 3。因此在相应花括号形成的作用域中，存在一个“死区”，起始于函数开头，终止与相关变量声明的一行。在这个范围内无法访问 let 或 const 声明的变量。这个“死区”的专业名称为：TDZ （Temporal Dead Zone）</p><p>块级作用域和暂时性死区。</p><p>之前的 var 变量，会有变量提升的概念。即你在任何处用 var 定义变量，一开始 js 引擎会将其变量置位顶部（以 <code>undefined</code> 的形式，再执行到赋值时，再赋值）</p><p>但是用 let、const 声明的变量，则不会有变量提升的概念，在定义 let 之前，不能调用 let 声明的变量，不然会报错，在块级作用域的开始到 let 声明的前一行，这块区域被称为<code>暂时性死区</code></p><p>变量提升和暂时性死区</p><p>var 会变量提升</p><p>function 会函数提升</p><p>函数提升的优先级大于变量提升</p><p>let、const 会引起暂时性死区</p><p>为什么？</p><p>因为</p><p>变量提升和暂时性死区算 feature(特性)还是 bug</p><p>ES6 规定，let/const 命令会使区块形成封闭的作用域。如在声明之前使用变量，就会报错。</p><p>总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。</p><p>这在语法上，称为“<strong>暂时性死区</strong>”（temporal dead zone，简称 TDZ）</p><p>也就是说由 let、const 声明的变量，在使用之前，这些变量都是不可用的</p><p>var 声明的会在预编译阶段进行变量提升，并且赋值 undefined</p><p>非表达式的函数也会进行函数声明，它的优先级大于 var</p><p>阮一峰：</p><blockquote><p>ES6 规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p></blockquote><p>作用域</p><p>​</p><p>代码提升是在预编译阶段进行，而代码执行阶段</p><p>预编译阶段会做三件事</p><p>​ 变量声明</p><p>​ 变量声明并进行提升，但是值为 undefined</p><p>​ 所有非表达式的函数声明进行提升（函数声明）</p><p><img src="https://i.loli.net/2021/06/04/9uaTpg7C3l8XxNb.png" alt="image-20210604173150466"></p><ol><li>当脚本开始运行，词法环境预先填充了所有的变量 <ul><li>最初，它们处于“未初始化（Uninitiallized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 <code>let</code> 声明前，不能引用它。几乎就像变量不存在一样。</li></ul></li><li>然后 <code>let phrase</code> 定义出现了。它尚未被赋值，因此它的值为 <code>undefined</code> 。从这一刻起，我们就可以使用变量了。</li></ol><p>第一个阶段，就是暂时性死区</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-hidden="true">#</a></h2><ul><li><a href="https://zh.javascript.info/closure" target="_blank" rel="noreferrer">闭包</a></li><li><a href="https://www.cnblogs.com/zhuzhenwei918/p/6131345.html" target="_blank" rel="noreferrer">ES6 之 let（理解闭包）和 const 命令</a></li><li><a href="https://zhuanlan.zhihu.com/p/28140450" target="_blank" rel="noreferrer">我用了两个月的时间才理解 let</a></li></ul>`,55),o=[e];function r(t,c,i,y,F,D){return a(),n("div",null,o)}const A=s(p,[["render",r]]);export{b as __pageData,A as default};
