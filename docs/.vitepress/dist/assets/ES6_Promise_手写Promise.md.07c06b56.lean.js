import{_ as l,c as p,o as e,d as a,a as s,b as n}from"./app.590c1fbf.js";const d=JSON.parse('{"title":"手写 Promise","description":"","frontmatter":{},"headers":[{"level":3,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":3,"title":"基本写法","slug":"基本写法","link":"#基本写法","children":[]},{"level":3,"title":"最小实现","slug":"最小实现","link":"#最小实现","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"relativePath":"ES6/Promise/手写Promise.md"}'),o={name:"ES6/Promise/手写Promise.md"},r=a("",19),c=s("ul",null,[s("li",null,[s("p",null,"onResolved 是 then 方法中的回调函数")]),s("li",null,[s("p",null,[n("源码第一行 "),s("code",null,"return new Promise"),n(" ，返回一个新的 Promise 实例，为什么要返回一个新的呢，因为规定说 then 要链式调用，而且 then 中的如果没有实例，就继承用上一个 Promise 实例，也就是说规则如此，所以我们必须 返回一个新的 Promise 实例")])]),s("li",{const:"",res:"","css-module":"."},[s("p",null,[s("code",null,"return new Promise((resolve) => {...})"),n(" 其实就和上文说的 fn 是一个味道，即执行 fn 函数，这个 fn 函数中，向 this.callbacks 数组 push 匿名函数() =>")])]),s("li",null,[s("p",null,"当 resolve(2)时，执行 this.callbacks 函数组成的数组。")]),s("li",null,[s("p",null,"如果 promise1.then() 执行后的值返回的是 promise，那么就让新的 Promise 实例再 then")]),s("li",null,[s("p",null,"如果是个普通值，那就执行 resolve(res)，依次执行 callbacks 里的函数")])],-1),t=a("",2),F=[r,c,t];function y(i,D,A,C,b,m){return e(),p("div",null,F)}const h=l(o,[["render",y]]);export{d as __pageData,h as default};
