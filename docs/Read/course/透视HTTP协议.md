# 透视 HTTP 协议笔记



## 课程目录

破冰篇

时势与英雄：HTTP 协议的前世今生

HTTP 是什么？HTTP 又不是什么

HTTP 世界全览（上）：与 HTTP 相关的各种概念

HTTP 世界全览（下）：与 HTTP 相关的各种协议

”七层“和”四层“是什么？”五层“”六层“哪去了？

域名里有哪些门道？

自己动手，搭建HTTP实验环境

基础篇

键入网址后按下回车，后面究竟发生了什么？

HTTP报文是什么样子的？

应该如何理解请求方法？

你能写出正确的网址吗？

响应状态码该怎么用？

HTTP 协议有哪些特点？

HTTP 有哪些优点和缺点？

进阶篇

海纳百川：HTTP 的实体数据

把大象装进冰箱：HTTP 传输大文件的方法

排队也要讲效率：HTTP 的连接管理

四通八达：HTTP 重定向和跳转

让我知道你是谁：HTTP 的 Cookie 机制

生鲜速递：HTTP 的缓存控制

良心中间商：HTTP 的代理服务

冷链周转：HTTP 的缓存代理

安全篇

HTTPS 是什么？SSL/TLC 又是什么？

固若金汤的根本（上）：对称加密与非对称加密

固若金汤的根本（下）：数字签名与证书

信任始于握手：TLS1.2 连接过程解析

更好更快的握手：TLS1.3 特性解析

连接太慢该怎么办：HTTPS 的优化

我应该迁移到 HTTPS 吗

飞翔篇

时代之风（上）：HTTP/2 特性概览

时代之风（下）：HTTP/2 内核剖析

未来之路：HTTP/3 展望

我应该迁移到 HTTP/2 吗？

探索篇

Nginx：高性能的 Web 服务器

OpenResty：更灵活的 Web 服务器

WAF：保护我们的网络服务

CDN：加速我们的网络服务

WebSocket：沙盒里的 TCP

总结篇

HTTP 性能优化面面观（上）

HTTP 性能优化面面观（下）



## HTTP 的前世今生

### 史前年代

20 世纪 60 年代，美国国防部高等研究计划署（ARPA）建立了 ARPA 网，它有四个分布在各地的节点，被认为是如今互联网的“始祖”。

70 年代，基于对 ARPA 网的实践和思考，研究人员发明出了著名的 TCP/IP 协议。并在 80 年代中期进入了 UNIX 系统内核，促使更多的计算机接入了互联网

### 创世纪

1989 年，任职于欧洲核子研究中心（CERN）的蒂姆·博纳斯·李发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术

1. URI：即统一资源标识符，作为互联网上资源的唯一身份；
2. HTML：即超文本标记语言，描述超文本文档；
3. HTTP：即超文本传输协议，用来传输超文本；

基于它们，就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web

### HTTP/0.9

它只支持纯文本格式，以及只允许“GET”请求，并且在相应请求之后立即关闭连接，功能有限

“把简单的系统变复杂”，要比“把复杂的系统变简单”容易的多

### HTTP/1.0

1993 年，NCSA（美国国家超级计算应用中心）开发出了 Mosaic，是第一个可以图文混排的浏览器，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作

同一时期，1992 年发明了 JPEG 图像格式，1995 年发明了 MP3 音乐格式

HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，例如：

1. 增加了 HEAD、POST 等新方法
2. 增加了响应状态码，标记可能的错误原因；
3. 引入了协议版本号概念；
4. 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和相应更加灵活；
5. 传输的数据不再仅限于文本

但 HTTP/1.0 并不是一个“标准”，只是记录已有实践和模式的一份参考文档，不具有实际的约束力，相当于一个“备忘录”

### HTTP/1.1

网景与微软的“浏览器大战”推动了 Web 的发展，在“浏览器大战”结束之后的 1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616，成为“正式的标准”。这意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个“立法”

HTTP/1.1 的主要变更有：

1. 增加了 PUT、DELETE 等新的方法；
2. 增加了缓存管理和控制；
3. 明确了连接管理，允许持久连接；
4. 允许相应数据分块（chunked），李渔传输大文件；
5. 强制要求 Host 头，让互联网主机托管成为可能

### HTTP/2

2015 年发布 HTTP/2，RFC 编号 7540，由 Google 推动，将自家的 SPDY 协议腿上标准的宝座，称为了 HTTP/2 协议

HTTP/2 的做东充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能上做了很大的改善，主要特点有：

1. 二进制协议，不再是纯文本；
2. 可发起多个请求，废弃了 1.1 里的管道；
3. 使用专用算法压缩头部，减少数据传输量；
4. 允许服务器主动向客户端推送数据；
5. 增强了安全性，“事实上”要求加密通信

虽然 HTTP/2 推出已经 5 个年头了，但因为 HTTP/1.1 实在太过经典和强势，目前普及率还比较低

### HTTP/3

Google 发明了一个新的协议，叫做 QUIC，目前 HTTP/3 在标准化指定阶段，也许要两三年后正式发布

### 历史回顾

1. HTTP 协议始于三十年前蒂姆·博纳斯·李的一篇论文
2. HTTP/0.9 是个简单的文本协议，只能获取文本资源；
3. HTTP/1.0 确立了大部分现有使用的技术，但它不是正式标准；
4. HTTP/1.1 是目前互联网上使用最广泛的协议，功能也非常完善；
5. HTTP/2 基于 Google 的 SPDY 协议，注重性能改善，但普及度不高
6. HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向



## HTTP 是什么？HTTP 又不是什么？

HTTP 就是超文本传输协议。它是协议、也是传输、又是超文本。但它不是互联网、不是编程语言、不是HTML、不是一个孤立的协议

1. HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。
2. HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由。
3. HTTP 传输的是文字、图片、音频、视频等超文本数据。
4. HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。



互联网（Internet）是遍布于全球的许多网络互相连接而形成的一个巨大的国际网络，在它上面存放着各式各样的资源，也对应着各式各样的协议，例如超文本资源使用 HTTP，普通文件使用 FTP，电子邮件使用 SMTP 和 POP3 等。

但毫无疑问，HTTP 是构建互联网的一块重要拼图，而且是占比最大的那一块。





## HTTP 世界全览：与 HTTP 相关的各种概念

![HTTP世界](https://s2.loli.net/2022/03/29/S7dwkq48TYK5m1z.png)

这张图左边的部分是与 HTTP 有关系的各种协议，比较偏向于理论；而右边的部分是与 HTTP 有关系的各种应用技术，偏向于实际应用。

先看右边这部分

![与HTTP相关的各种概念](https://s2.loli.net/2022/03/29/6YShwn5WuFgRMCO.png)

互联网的正式名称是 Internet，里面存储着无穷无尽的信息资源，我们通常所说的 **上网** 实际上访问的只是互联网的一个子集 「万维网（World Wide Web）」，**它基于 HTTP 协议** ，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。

互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。

1. 互联网上绝大部分资源都使用 HTTP 协议传输；
2. 浏览器是 HTTP 协议里的请求方，即 User Agent；
3. 服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；
4. CDN 位于浏览器和服务器之间，主要起到缓存加速的作用；
5. 爬虫是另一类 User Agent，是自动访问网络资源的程序

## HTTP 世界全览：与 HTTP 相关的各种协议

在上一讲中，我介绍了与 HTTP 相关的浏览器、服务器、CDN、网络爬虫等应用技术。

今天要讲的则是比较偏向于理论的各种 HTTP 相关协议，重点是 TCP/IP、DNS、URI、HTTPS 等，希望能够帮你理清楚它们与 HTTP 的关系。

![HTTP 相关协议](https://s2.loli.net/2022/03/29/JxZCY3jEtpvcLR1.png)

#### TCP/IP

TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 **TCP** 和 **IP** ，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。

这个协议栈有四层，最上层是 **应用层**，最下层是 **链接层** ，TCP 和 IP 则在中间：**TCP 属于传输层，IP 属于网际层** 。

**IP 协议** 是 **Internet Protocol** 的缩写，**主要目的是解决寻址和路由问题，以及如何在两点间传送数据包** 。IP 协议使用 **IP 地址** 的概念来定位互联网上的每一台计算机。可以对比一下现实中的电话系统，你拿着的手机相当于互联网上的计算机，而要打电话就必须接入电话网，由通信公司给你分配一个号码，这个号码就相当于 IP 地址。

现在我们使用的 IP 协议大多数是 v4 版，地址是四个用 `.` 分隔的数字，例如 `192.168.0.1` ，总共有 2^32，大约 42 亿个可以分配的地址。看上去好像很多，但互联网的快速发展让地址的分配管理很快就捉襟见肘。所以，就又出现了 v6 版，使用 8 组 `:` 分隔的数字作为地址，容量扩大了很多，有 2^128 个，在未来的几十年里应该是足够用了。

**TCP 协议**是 `Transmission Control Protocol` 的缩写，意思是 **传输控制协议** ，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。

#### DNS

DNS 域名是 IP 地址的等价替代，需要用域名解析实现到 IP 地址的映射；

#### URI/URL

DNS 和 IP 地址只是标记了互联网上的主机，但主机上有那么多文本、图片、页面，到底要找哪一个呢？

所以就出现了 URI（Uniform Resource Identifier），中文名称是 **统一资源标识符** ，使用它就能够唯一地标记互联网上资源。

URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， **统一资源定位符** ，也就是我们俗称的「网址」，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。

URI 主要有三个基本的部分构成：

1. 协议名：即访问该资源应当使用的协议，在这里是 `http`；
2. 主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是 `nginx.org`；
3. 路径：即资源在主机上的位置，使用 `/` 分隔多级目录，在这里是 `/en/download.html` 

#### HTTPS

HTTPS 就相当于这个比喻中的「火星文」，它的全称是 **HTTP over SSL/TLS** ，也就是运行在 SSL/TLS 协议上的 HTTP。

注意它的名字，这里是 SSL/TLS，而不是 TCP/IP，它是一个 **负责加密通信的安全协议** ，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。

因为 HTTPS 相当于 `HTTP+SSL/TLS+TCP/IP` ，其中的 `HTTP` 和 `TCP/IP` 我们都已经明白了，只要再了解一下 SSL/TLS，HTTPS 也就能够轻松掌握。

SSL 的全称是 `Secure Socket Layer` ，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即 `Transport Layer Security`，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。

SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。

#### 代理

代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为 **中转站** ，既可以转发客户端的请求，也可以转发服务器的应答。

代理有很多的种类，常见的有：

1. 匿名代理：完全 **隐匿** 了被代理的机器，外界看到的只是代理服务器；
2. 透明代理：顾名思义，它在传输过程中是 **透明开放** 的，外界既知道代理，也知道客户端；
3. 正向代理：靠近客户端，代表客户端向服务器发送请求；
4. 反向代理：靠近服务器端，代表服务器响应客户端的请求；

这次我介绍了与 HTTP 相关的各种协议，在这里简单小结一下今天的内容。

1. TCP/IP 是网络世界最常用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上；
2. DNS 域名是 IP 地址的等价替代，需要用域名解析实现到 IP 地址的映射；
3. URI 是用来标记互联网上资源的一个名字，由 `协议名 + 主机名 + 路径` 构成，俗称 URL；
4. HTTPS 相当于 `HTTP+SSL/TLS+TCP/IP` ，为 HTTP 套了一个安全的外壳；
5. 代理是 HTTP 传输过程中的中转站，可以实现缓存加速、负载均衡等功能。



## 常说的四层和七层到底是什么？五层、六层哪去了？

### TCP/IP 网络分层模型

![TCP/IP 网络分层模型](https://s2.loli.net/2022/03/29/l3m8kJDCf5ZdjSh.png)

TCP/IP 协议总共有四层，就像搭积木一样，每一层需要下层的支撑，同时又支撑着上层，任何一层被抽掉都可能会导致整个协议栈坍塌。

第一层叫 **链接层** （link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 **MAC 地址来标记网络上的设备** ，所以有时候也叫 MAC 层。

第二层叫 **网际层** 或者 **网络互连层** （internet layer），IP 协议就处在这一层。因为 IP 协议定义了 **IP 地址** 的概念，所以就可以在 **链接层** 的基础上，**用 IP 地址取代 MAC 地址** ，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再「翻译」成 MAC 地址就可以了。

第三层叫 **传输层**（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间可靠地传输，是 TCP 协议工作的层次，另外还有它的一个小伙伴 UDP。

**TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据** ，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的字节流，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。

关于 TCP 和 UDP 可以展开讨论的话题还有很多，比如最经典的「三次握手」和「四次挥手」，一时半会很难说完，好在与 HTTP 的关系不是太大，以后遇到了再详细讲解。

协议栈的第四层叫 **应用层** （application layer），由于下面的三层把基础打得非常好，所以在这一层就百花齐放了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。

- MAC 层的传输单位是帧（frame）
- IP 层的传输单位是包（packet）
- TCP 层的传输单位是段（segment）
- HTTP 的传输单位则是消息或报文（message）

### OSI 网络分层模型

第二个网络分层模型：**OSI** ，全称是 **开放式系统互联通信参考模型** （Open System Interconnection Reference Model）。

![OSI 网络分层模型](https://s2.loli.net/2022/03/29/pLzfhyXKHosTR6Z.png)

1. 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；
2. 第二层：数据链路层，它基本相当于 TCP/IP 的链接层；
3. 第三层：网络层，相当于 TCP/IP 里的网际层；
4. 第四层：传输层，相当于 TCP/IP 里的传输层；
5. 第五层：会话层，维护网络中的连接状态，即保持会话和同步；
6. 第六层：表示层，把数据转换为合适、可理解的语法和语义；
7. 第七层：应用层，面向具体的应用传输数据。

不过国际标准组织心里也很清楚，TCP/IP 等协议已经在许多网络上实际运行，再推翻重来是不可能的。所以，OSI 分层模型在发布的时候就明确地表明是一个「参考」，不是强制标准，意思就是说，「你们以后该干什么还干什么，我不管，但面子上还是要按照我说的来」。



### 两个分层模型的映射关系

现在我们有了两个网络分层模型：TCP/IP 和 OSI，新的问题又出现了，一个是四层模型，一个是七层模型，这两者应该如何互相映射或者说互相解释呢？

好在 OSI 在设计之初就参考了 TCP/IP 等多个协议，可以比较容易但不是很精确地实现对应关系。

![两个分层模型的映射关系](https://s2.loli.net/2022/03/29/NGdR1VHo4LeXDb7.png)

1. 第一层：物理层，TCP/IP 里无对应；
2. 第二层：数据链路层，对应 TCP/IP 的链接层；
3. 第三层：网络层，对应 TCP/IP 的网际层；
4. 第四层：传输层，对应 TCP/IP 的传输层；
5. 第五、六、七层：统一对应到 TCP/IP 的应用层。

### TCP/IP 协议栈的工作方式

你可以把 HTTP 利用 TCP/IP 协议栈传输数据想象成一个发快递的过程。

![TCP/IP 协议栈的工作方式](https://s2.loli.net/2022/03/29/quf6FtHB5mK1dk9.png)

这次我们学习了 HTTP 所在的网络分层模型，它是工作中常用的交流语言，在这里简单小结一下今天的内容。

1. TCP/IP 分为四层，核心是二层的 IP 和三层的 TCP，HTTP 在第四层；
2. OSI 分为七层，基本对应 TCP/IP，TCP 在第四层，HTTP 在第七层；
3. OSI 可以映射到 TCP/IP，但这期间一、五、六层消失了；
4. 日常交流的时候我们通常使用 OSI 模型，用四层、七层等术语；
5. HTTP 利用 TCP/IP 协议栈逐层打包再拆包，实现了数据传输，但下面的细节并不可见。

有一个辨别四层和七层比较好的（但不是绝对的）小窍门，**两个凡是**：

- 凡是由操作系统负责处理的就是四层或四层以下，
- 否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。



## 域名里有哪些门道



### 域名的形式

域名是一个有层次的结构，是一串用 `.` 分隔的多个单词，最右边的被称为 **顶级域名**，然后是 **二级域名** ，层级关系向左依次降低。

域名不仅能够代替 IP 地址，还有许多其他的用途。

在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用 `server_name` 指令：

```nginx
server {
    listen 80;
    server_name time.geekbang.org; # 主机名是 time.geekbang.org
}
```

### 域名的解析

就像 IP 地址必须转换成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是 **域名解析** 。

DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：

1. 根域名服务器（Root DNS Server）：管理顶级域名服务器，返回 `com`、`net`、`cn` 等顶级域名服务器的 IP 地址；
2. 顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；
3. 权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 `www.apple.com` 的 IP 地址。

![DNS服务器](https://s2.loli.net/2022/03/29/MJiKOApEuLIqsoN.png)

在这里根域名服务器是关键，它必须是众所周知的，否则下面的各级服务器就无从谈起了。目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到。

例如，你要访问 `www.apple.com` ，就要进行下面的三次查询：

1. 访问根域名服务器，它会告诉你 `com` 顶级域名服务器的地址；
2. 访问 `com` 顶级域名服务器，它再告诉你 `apple.com` 域名服务器的地址；
3. 最后访问 `apple.com` 域名服务器，就得到了 `www.apple.com` 的地址。

所以在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是 **缓存** 

这些「野生」服务器被称为「非权威域名服务器」，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址

比较知名的 DNS 有 Google 的 `8.8.8.8`，Microsoft 的 `4.2.2.1` ，还有 CloudFlare 的 `1.1.1.1` 等等

另外，操作系统里还有一个特殊的 **主机映射** 文件，通常是一个可编辑的文本，在 Linux 里是 `/etc/hosts`，在 Windows 里是 `C:\WINDOWS\system32\drivers\etc\hosts` ，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。

下面的这张图比较完整地表示了现在的 DNS 架构。

![DNS 架构](https://s2.loli.net/2022/03/29/Qsh6wrFV5puOdLf.png)



### 域名的新玩法

可信的 DNS

- 重定向、名字服务器、基于域名实现的负载均衡

不怀好意的 DNS

- **域名屏蔽** ，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站；
- **域名劫持** ，也叫 **域名污染**，你要访问 A 网站，但 DNS 给了你 B 网站。

这次我们学习了与 HTTP 协议有重要关系的域名和 DNS，在这里简单小结一下今天的内容：

1. 域名使用字符串来代替 IP 地址，方便用户记忆，本质上一个名字空间系统；
2. DNS 就像是我们现实世界里的电话本、查号台，统管着互联网世界里的所有网站，是一个超级大管家；
3. DNS 是一个树状的分布式查询系统，但为了提高查询效率，外围有多级的缓存；
4. 使用 DNS 可以实现基于域名的负载均衡，既可以在内网，也可以在外网



## 自己动手，搭建 HTTP 实验环境

回顾：

HTTP 协议诞生于 30 年前，设计之初的目的是用来传输纯文本数据。但由于形式灵活，搭配 URI、HTML 等技术能够把互联网上的资源都联系起来，构成一个复杂的超文本系统，让人们自由地获取信息，所以得到了迅猛发展。

HTTP 有多个版本，目前应用的最广泛的是 HTTP/1.1，它几乎可以说是整个互联网的基石。但 HTTP/1.1 的性能难以满足如今的高流量网站，于是又出现了 HTTP/2 和 HTTP/3。不过这两个新版本的协议还没有完全推广开。在可预见的将来，HTTP/1.1 还会继续存在下去。

HTTP 翻译成中文是 **超文本传输协议** ，是一个应用层的协议，通常基于 TCP/IP，能够在网络的任意两点之间传输文字、图片、音频、视频等数据。

HTTP 协议中的两个端点称为 **请求方** 和 **应答方** 。请求方通常就是 Web 浏览器，也叫 user agent，应答方是 Web 服务器，存储着网络上的大部分静态或动态的资源。

在浏览器和服务器之间还有一些 **中间人** 的角色，如 CDN、网关、代理等，它们也同样遵守 HTTP 协议，可以帮助用户更快速、更安全地获取资源。

HTTP 协议不是一个孤立的协议，需要下层很多其他协议的配合。最基本的是 TCP/IP，实现寻址、路由和可靠的数据传输，还有 DNS 协议实现对互联网上主机的定位查找。

对 HTTP 更准确的称呼是 **HTTP over TCP/IP** ，而另一个 **HTTP over SSL/TLS** 就是增加了安全功能的 HTTPS



## 键入网址再按下回车，后面究竟发生了什么？

抓包分析

![HTTP连接](https://s2.loli.net/2022/03/30/1oehYVXd3NGLbPQ.png)

#### 使用域名访问 Web 服务器

多出了一个访问 hosts 文件的动作，也就是本机的 DNS 解析

![DNS解析](https://s2.loli.net/2022/03/30/zJHRbL1dafEkiuj.png)

#### 真实的网络世界

第一个实验是最简单的场景，只有两个角色：浏览器和服务器，浏览器可以直接用 IP 地址找到服务器，两者直接建立 TCP 连接后发送 HTTP 报文通信。

第二个实验在浏览器和服务器之外增加了一个 DNS 的角色，浏览器不知道服务器的 IP 地址，所以必须要借助 DNS 的域名解析功能得到服务器的 IP 地址，然后才能与服务器通信。

真实的互联网世界要比这两个场景要复杂的多，我利用下面的这张图来做一个详细的说明。

![真实的网络世界](https://s2.loli.net/2022/03/30/vOYJ7mqrCLI5ezH.png)



1. HTTP 协议基于底层的 TCP/IP 协议，所以必须要用 IP 地址建立连接；
2. 如果不知道 IP 地址，就要用 DNS 协议去解析得到 IP 地址，否则就会连接失败；
3. 建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析报文；
4. 为了减少响应时间，整个过程中的每一个环节都会有缓存，能够实现「短路」操作；
5. 虽然现实中的 HTTP 传输过程非常复杂，但理论上仍然可以简化成实验里的「两点」模型

## HTTP 报文是什么样子的？

HTTP 协议基本工作流程，也就是 **请求 - 应答**，**一发一收** 的模式

那么 HTTP 协议的核心部分是什么呢？

答案就是它 **传输的报文内容**。

HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

1. 起始行（start line）：描述请求或响应的基本信息；
2. 头部字段集合（header）：使用 key-value 形式更详细地说明报文；
3. 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

![原始抓包的数据](https://s2.loli.net/2022/03/30/MsWfNtH36yIK2gb.png)

在这个浏览器发出的请求报文里，第一行 `GET / HTTP/1.1` 就是请求行，而后面的 Host、Connection 等等都属于 header，报文的最后是一个空白行结束，没有 body。

### 请求行

了解了 HTTP 报文的基本结构后，我们来看看请求报文里的起始行也就是 **请求行**（request line），它简要地描述了 **客户端想要如何操作服务器端的资源** 。

请求行由三部分构成：

1. 请求方法：是一个动词，如 GET/POST，表示对资源的操作；
2. 请求目标：通常是一个 URI，标记了请求方法要操作的资源；
3. 版本号：表示报文使用的 HTTP 协议版本。

例如

```markdown
GET / HTTP/1.1
```

在这个请求行里，`GET` 是请求方法，`/` 是请求目标，`HTTP/1.1` 是版本号，把这三部分连起来，意思就是「服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。」

### 状态行

看完了请求行，我们再看响应报文里的起始行，在这里它不叫 **响应行**，而是叫 **状态行**（status line），意思是 **服务器响应的状态**。

比起请求行来说，状态行要简单一些，同样也是由三部分构成：

1. 版本号：表示报文使用的 HTTP 协议版本；
2. 状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；
3. 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。

例如：

```markdown
HTTP/1.1 200 OK
```

意思就是：「浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是 1.1，状态码是 200，一切 OK。」

### 常用头字段

HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：

1. 通用字段：在请求头和响应头里都可以出现；
2. 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；
3. 响应字段：仅能出现在响应头里，补充说明响应报文的信息；
4. 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。

#### Host

它属于 **请求字段**，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求 **必须出现** 的字段

Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的 **路由重定向** 

#### User-Agent

**User-Agent** 是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面

#### Date

**Date** 字段是一个 **通用字段** ，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。

#### Server

**Server** 字段是 **响应字段**，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号

#### Content-Length

实体字段里要说的一个是 **Content-Length** ，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度

### 小结

1. HTTP 报文结构就像是「大头儿子」，由「起始行 + 头部 + 空行 + 实体」组成，简单地说就是「header+body」；
2. HTTP 报文可以没有 body，但必须要有 header，而且 header 后也必须要有空行，形象地说就是大头必须要带着脖子；
3. 请求头由「请求行 + 头部字段」构成，响应头由「状态行 + 头部字段」构成；
4. 请求行有三部分：请求方法，请求目标和版本号；
5. 状态行也有三部分：版本号，状态码和原因字符串；
6. 头部字段是 key-value 的形式，用 `:` 分隔，不区分大小写，顺序任意，除了规定的标准头，也可以任意添加自定义字段，实现功能扩展；
7. HTTP/1.1 里唯一要求必须提供的头字段是 Host，它必须出现在请求头里，标记虚拟主机名

## 应该如何理解请求方法？



目前 HTTP/1.1 规定了八种方法，单词 **都必须是大写的形式** ，我先简单地列把它们列出来，后面再详细讲解。

1. GET：获取资源，可以理解为读取或者下载数据；
2. HEAD：获取资源的元信息；
3. POST：向资源提交数据，相当于写入或上传数据；
4. PUT：类似 POST；
5. DELETE：删除资源；
6. CONNECT：建立特殊的连接隧道；
7. OPTIONS：列出可对资源实行的方法；
8. TRACE：追踪请求 - 响应的传输路径。

### GET/HEAD

**GET** 方法应该是 HTTP 协议里最知名的请求方法了，它的含义是请求 **从服务器获取资源** ，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。

**HEAD** 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的 **元信息** 。

### POST/PUT

POST 也是一个经常用到的请求方法，使用频率应该是仅次于 GET，应用的场景也非常多，只要向服务器发送数据，用的大多数都是 POST。

PUT 的作用与 POST 类似，也可以向服务器提交数据，但与 POST 存在微妙的不同，通常 POST 表示的是「新建（create）」的含义，而 PUT 则是「修改（update）」的含义。

### DELETE

指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。

### CONNECT

是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。

### OPTIONS

方法要求服务器列出可对资源实行的操作方法，**在响应头的 Allow 字段里返回** 。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持

### TRACE

多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用



## 你能写出正确的网址吗？

### URI 的格式

下面的这张图显示了 URI 最常用的形式，由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略。

![URI 的格式](https://s2.loli.net/2022/03/30/iequjRQfXUAxywV.png)

### URI 的基本组成

URI 第一个组成部分叫 **scheme** ，翻译成中文叫 **方案名** 或者 **协议名** ，表示 **资源应该使用哪种协议** 来访问。

最常见的当然就是 http 了，表示使用 HTTP 协议。另外还有 https ，表示使用经过加密、安全的 HTTPS 协议。此外还有其他不是很常见的 scheme，例如 ftp、ldap、file、news 等。

### 小结

1. URI 是用来唯一标记服务器上资源的一个字符串，通常也称为 URL；
2. URI 通常由 scheme、host:port、path 和 query 四个部分组成，有的可以省略；
3. scheme 叫方案名或者协议名，表示资源应该使用哪种协议来访问；
4. `host:port` 表示资源所在的主机名和端口号；
5. path 标记资源所在的位置；
6. query 表示对资源附加的额外要求；
7. 在 URI 里对 `@&/` 等特殊字符和汉字必须要做编码，否则服务器收到 HTTP 报文后会无法正确处理

## 响应状态码该怎么用？

### 状态码

**RFC 标准把状态码分成了五类** ，用数字的第一位表示分类，而 0~99 不用，这样状态码的实际可用范围就大大缩小了，由 000~999 变成了 100~599。

这五类的具体含义是：

- 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
- 2××：成功，报文已经收到并被正确处理；
- 3××：重定向，资源位置发生变动，需要客户端重新发送请求；
- 4××：客户端错误，请求报文有误，服务器无法处理；
- 5××：服务器错误，服务器在处理请求时内部发生了错误。

目前 RFC 标准里总共有 41 个状态码

### 1××

1×× 类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。

我们偶尔能够见到的是 **101 Switching Protocols** 。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。

### 2××

2×× 类状态码表示 **服务器收到并成功处理了客户端的请求** ，这也是客户端最愿意看到的状态码。

#### 200 OK

是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据

#### 204 No Content

是另一个很常见的成功状态码，它的含义与 `200 OK` 基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的

#### 206 Partial Content

是 HTTP 分块下载或断点续传的基础，在客户端发送 **范围请求**、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。

### 3××

3×× 类状态码表示 **客户端请求的资源发生了变动** ，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的 **重定向** ，包括著名的 301、302 跳转。

#### 301 Moved Permanently

俗称 **永久重定向** ，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。

#### 302 Found

与 301 类似，曾经的描述短语是 **Moved Temporarily** ，俗称 **临时重定向** ，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。

301 和 302 都会在响应头里使用字段 **Location** 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是 **永久** ，一个是 **临时** ，所以在场景、用法上差距很大。

比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是永久的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS

#### 304 Not Modified

它用于 `If-Modified-Since` 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成 **重定向已到缓存的文件**（即缓存重定向）

### 4××

4×× 类状态码表示 **客户端发送的请求报文有误** ，服务器无法处理，它就是真正的 **错误码** 含义了。

#### 400 Bad Request

是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是一头雾水、不知所措。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。

#### 403 Forbidden

实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个闭门羹。

#### 404 Not Found

可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被「用滥了」，只要服务器不高兴就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌

4×× 里剩下的一些代码较明确地说明了错误的原因

- 405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；
- 406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；
- 408 Request Timeout：请求超时，服务器等待了过长的时间；
- 409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；
- 413 Request Entity Too Large：请求报文里的 body 太大；
- 414 Request-URI Too Long：请求行里的 URI 太大；
- 429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；
- 431 Request Header Fields Too Large：请求头某个字段或总体太大

###  5××

5×× 类状态码表示 **客户端请求报文正确，但服务器在处理时内部发生了错误** ，无法返回应有的响应数据，是服务器端的错误码。

#### 500 Internal Server Error

与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。

#### 501 Not Implemented

表示客户端请求的功能还不支持，这个错误码比 500 要温和一些，和即将开业，敬请期待的意思差不多，不过具体什么时候开业就不好说了。

#### 502 Bad Gateway

通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的

#### 503 Service Unavailable

表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的「网络服务正忙，请稍后重试」的提示信息就是状态码 503。

503 是一个「临时」的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个 **Retry-After** 字段，指示客户端可以在多久以后再次尝试发送请求



## HTTP 有哪些特点？

1. HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；
2. HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；
3. HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；
4. HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；
5. HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。





## HTTP有哪些优点？又有哪些缺点？

不过在正式开讲之前我还要提醒你一下，**今天的讨论范围仅限于 HTTP/1.1** ，所说的优点和缺点也仅针对 HTTP/1.1。实际上，专栏后续要讲的 HTTPS 和 HTTP/2 都是对 HTTP/1.1 优点的发挥和缺点的完善。

1. HTTP 最大的优点是简单、灵活和易于扩展；
2. HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；
3. HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；
4. HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；
5. HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；
6. HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。
