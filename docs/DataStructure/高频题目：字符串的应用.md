# 高频题目：字符串的应用



## 基本算法技能

### 反转字符串

```javascript
// 定义为反转的字符串
const str = 'johan'
// 定义反转后的字符串
const res = str.split('').reverse().join('')
console.log(res) // nahoj
```



### 判断一个字符串是否是回文字符串

```javascript
'naan'
// 方法1
const isPalindrome = (str) => {
    // 先反转字符串
    const reversedStr = str.split('').reverse().join('')
    // 判断反转前后是否相等
    return reversedStr === str
}
// 方法2
const isPalindrome2 = (str) => {
    // 缓存字符串的长度
    const len = str.length
    // 遍历前半部分，判断和后半部分是否相等
    for (let i = 0; i < len/2; i++) {
        if (str[i] !== str[len-i-1]) {
            return false
        }
    }
    return true
}
```



## 高频真题解读

### 回文字符串的衍生问题

> 真题描述：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

> 示例 1:

输入: "aba"
输出: True
示例 2:
输入: "abca"
输出: True
解释: 你可以删除c字符。
注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。



 字符串题干中若有“回文”关键字，那么做题时脑海中一定要冒出两个关键字——**对称性** 和 **双指针**。这两个工具一起上，足以解决大部分的回文字符串衍生问题。 

```javascript
const validPalindrome = (s) => {
    // 缓存字符串的长度
    const len = s.length
    // i、j 分别为左右指针
    let i=0,j=len-1
    // 当左右指针军满足对称时，一起向中间前进
    while(i < j && s[i] ===s[j]) {
        i++
        j--
    }
    // 尝试判断跳过左指针元素后字符串是否回文
    if(isPalindrome(i+1, j)) {
        return true
    }
    // 尝试判断跳过右指针元素后字符串是否回文
    if(isPalindrome(i, j-1)) {
        return true
    }
    // 工具方法，用于判断字符串回文
    function isPalindrome(st, ed) {
        while (st < ed) {
            if (s[st] !== s[ed]) {
                return false
            }
            st++
            ed--
        }
        return true
    }
    // 默认返回 false
    return false
}
```

### 字符串匹配问题——正则表达式初相见

接下来我们来看一道综合性比较强的字符串大题：

> 真题描述： 设计一个支持以下两种操作的数据结构：

void addWord(word)
bool search(word)
search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。
. 可以表示任何一个字母。

> 示例:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
说明:
你可以假设所有单词都是由小写字母 a-z 组成的。



















